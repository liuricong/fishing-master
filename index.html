<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="screen-orientation" content="landscape">
    <title>æ•é±¼å¤§äº¨ - æ·±æµ·ä¼ å¥‡</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            touch-action: none;
        }

        /* æ¸¸æˆå±‚ */
        #gameCanvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI å±‚ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            display: none;
        }

        /* é¡¶éƒ¨ä¿¡æ¯æ  */
        .hud-top {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 20px;
        }

        .hud-box {
            background: rgba(0, 20, 40, 0.85);
            padding: 8px 24px;
            border-radius: 50px;
            border: 2px solid #00ddee;
            box-shadow: 0 0 15px rgba(0, 221, 238, 0.3);
            color: #fff;
            font-size: 18px;
            display: flex;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .hud-value {
            font-weight: bold;
            font-size: 24px;
            color: #fff;
            margin-left: 10px;
            text-shadow: 0 0 5px #0ff;
        }

        #coin-icon { color: #FFD700; margin-right: 5px; font-size: 22px; }

        /* åº•éƒ¨ç‚®å°æ§åˆ¶åŒº - ä¼˜åŒ–å¸ƒå±€ */
        .controls-bottom {
            position: absolute;
            bottom: 30px; /* ä¸Šç§»ï¼Œä¸ç‚®å°å¯¹é½ */
            left: 0;
            right: 0;
            height: 50px;
            pointer-events: none;
        }
        
        /* å·¦ä¾§å‡å·æŒ‰é’® - ç»å¯¹å®šä½ */
        .controls-bottom .btn-change:first-child {
            position: absolute;
            left: calc(50% - 110px); /* å¢åŠ è·ç¦»ï¼Œç‚®å°ä¸­å¿ƒå·¦ä¾§110px */
            bottom: 0; /* ä¸ç‚®å°åº•éƒ¨å¯¹é½ */
        }
        
        /* å³ä¾§åŠ å·æŒ‰é’® - ç»å¯¹å®šä½ */
        .controls-bottom .btn-change:last-child {
            position: absolute;
            right: calc(50% - 110px); /* å¢åŠ è·ç¦»ï¼Œç‚®å°ä¸­å¿ƒå³ä¾§110px */
            bottom: 0; /* ä¸ç‚®å°åº•éƒ¨å¯¹é½ */
        }

        .btn-change {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, 
                        rgba(100, 200, 255, 0.8), 
                        rgba(0, 150, 255, 0.6),
                        rgba(0, 100, 200, 0.7));
            border: 1.5px solid rgba(200, 240, 255, 0.8);
            color: #fff;
            font-size: 20px;
            line-height: 33px;
            font-weight: bold;
            cursor: pointer;
            text-align: center;
            box-shadow: 
                0 0 12px rgba(100, 200, 255, 0.5),
                inset 0 -2px 8px rgba(0, 50, 100, 0.4),
                inset 0 2px 8px rgba(255, 255, 255, 0.3),
                0 3px 10px rgba(0, 0, 0, 0.4);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
            pointer-events: auto;
            position: relative;
            overflow: hidden;
        }

        /* æŒ‰é’®å†…éƒ¨æ°”æ³¡æ•ˆæœ */
        .btn-change::before {
            content: '';
            position: absolute;
            top: 20%;
            left: 25%;
            width: 6px;
            height: 6px;
            background: rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            animation: bubble-float 3s ease-in-out infinite;
        }

        .btn-change::after {
            content: '';
            position: absolute;
            top: 60%;
            right: 20%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            animation: bubble-float 2.5s ease-in-out infinite 0.5s;
        }

        @keyframes bubble-float {
            0%, 100% {
                transform: translateY(0) scale(1);
                opacity: 0.6;
            }
            50% {
                transform: translateY(-6px) scale(1.2);
                opacity: 0.3;
            }
        }

        .btn-change:hover {
            transform: scale(1.1) translateY(-2px);
            border-color: rgba(255, 255, 255, 0.9);
            box-shadow: 
                0 0 20px rgba(100, 200, 255, 0.7),
                inset 0 -2px 10px rgba(0, 50, 100, 0.5),
                inset 0 2px 10px rgba(255, 255, 255, 0.4),
                0 5px 15px rgba(0, 0, 0, 0.5);
            background: radial-gradient(circle at 30% 30%, 
                        rgba(150, 220, 255, 0.9), 
                        rgba(50, 180, 255, 0.7),
                        rgba(0, 120, 220, 0.8));
        }

        .btn-change:active {
            transform: scale(1.02) translateY(0);
            box-shadow: 
                0 0 15px rgba(100, 200, 255, 0.5),
                inset 0 1px 8px rgba(0, 50, 100, 0.5),
                inset 0 -1px 8px rgba(255, 255, 255, 0.2),
                0 2px 10px rgba(0, 0, 0, 0.4);
        }


        /* å¼€å§‹ç•Œé¢ */
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: transparent;
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #fff;
        }
        #start-screen::before {
            content: '';
            position: absolute;
            inset: 0;
            background:
                radial-gradient(1200px 600px at 80% -10%, rgba(0,180,216,0.25), transparent 60%),
                radial-gradient(900px 500px at -10% 110%, rgba(0,119,182,0.20), transparent 60%),
                radial-gradient(800px 500px at 50% 50%, rgba(72,202,228,0.08), transparent 60%),
                linear-gradient(180deg, rgba(0,26,51,0.95), rgba(0,51,102,0.95));
            z-index: -1;
        }
        /* é¦–é¡µ Canvas èƒŒæ™¯å±‚ */
        #homepageCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .title {
            font-size: 60px;
            font-weight: 900;
            background: linear-gradient(to bottom, #FFD700, #FFA500);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            margin-bottom: 20px;
            letter-spacing: 5px;
        }

        .subtitle {
            font-size: 18px; color: #0ff; margin-bottom: 50px; opacity: 0.8; letter-spacing: 2px;
        }

        .btn-start {
            padding: 15px 60px;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            background: linear-gradient(90deg, #00C6FF, #0072FF);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 198, 255, 0.6);
            transition: all 0.3s;
            animation: pulse 2s infinite;
        }

        .btn-start:hover { transform: scale(1.1); box-shadow: 0 0 40px rgba(0, 198, 255, 0.8); }

        #toast {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: #ff4444; padding: 10px 20px;
            border-radius: 10px; font-size: 20px; font-weight: bold; pointer-events: none;
            opacity: 0; transition: opacity 0.3s; z-index: 5; border: 1px solid #ff4444;
            white-space: nowrap; /* é˜²æ­¢æ–‡æ¡ˆæ¢è¡Œ */
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 198, 255, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(0, 198, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 198, 255, 0); }
        }

        /* æš‚åœæŒ‰é’® */
        .pause-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 10;
            pointer-events: auto;
        }
        .pause-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.5);
        }
        .pause-btn.hidden {
            display: none;
        }
        
        /* æš‚åœç•Œé¢ */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }
        .overlay.hidden {
            display: none;
        }
        #pauseScreen {
            background: rgba(0,20,40,0.95);
        }
        .pause-title {
            font-size: 28px;
            color: #fff;
            font-weight: 700;
            margin-bottom: 30px;
        }
        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .pause-btn-action {
            padding: 16px 50px;
            border-radius: 30px;
            border: none;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .pause-btn-action.continue {
            background: linear-gradient(135deg, #ff69b4 0%, #ff1493 100%);
            color: #fff;
            box-shadow: 0 8px 25px rgba(255,105,180,0.4);
        }
        .pause-btn-action.continue:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 35px rgba(255,105,180,0.5);
        }
        .pause-btn-action.quit {
            background: linear-gradient(135deg, #666 0%, #444 100%);
            color: #fff;
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
        }
        .pause-btn-action.quit:hover {
            transform: scale(1.05);
        }

        /* æ¨ªå±æ—‹è½¬æç¤º - ç«–å±æ¸¸æˆ */
        #rotateWarning {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #001a33 0%, #003366 50%, #004080 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        .rotate-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: rotate-phone 2s ease-in-out infinite;
        }
        @keyframes rotate-phone {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-90deg); }
            75% { transform: rotate(90deg); }
        }
        .rotate-text {
            color: #fff;
            font-size: 24px;
            font-weight: 600;
            text-align: center;
            margin-bottom: 10px;
        }
        .rotate-hint {
            color: rgba(255,255,255,0.6);
            font-size: 16px;
            text-align: center;
        }
        /* åªåœ¨è§¦å±è®¾å¤‡ç«–å±æ—¶æ˜¾ç¤ºæ—‹è½¬æç¤º */
        @media (pointer: coarse) and (orientation: portrait) and (min-height: 600px) {
            #rotateWarning {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <!-- æ¨ªå±æ—‹è½¬æç¤º -->
    <div id="rotateWarning">
        <div class="rotate-icon">ğŸ“±</div>
        <div class="rotate-text">è¯·æ—‹è½¬è®¾å¤‡</div>
        <div class="rotate-hint">æ¨ªå±æ¸¸æˆä½“éªŒæ›´ä½³</div>
    </div>
    <!-- èƒŒæ™¯å›¾ Base64 -->
    <script src="./static/bg-base64.js"></script>

<div id="start-screen">
    <canvas id="homepageCanvas"></canvas>
    <!-- é¦–é¡µé‡‘å¸æ˜¾ç¤º -->
    <div class="hud-top" style="z-index: 1;">
        <div class="hud-box">
            <span style="color: #FFD700; margin-right: 5px; font-size: 22px;">$</span>
            <span>é‡‘å¸</span>
            <span id="homepage-score" class="hud-value">200</span>
        </div>
    </div>
    <div class="title" style="z-index: 1;">æ•é±¼å¤§äº¨</div>
    <div class="subtitle" style="z-index: 1;">æ·±æµ·æ•çŒ Â· ç­–ç•¥ä¸ºç‹</div>
    <button class="btn-start" onclick="startGame()" style="z-index: 1;">å¼€å§‹æ•é±¼</button>
</div>

<div id="ui-layer">
    <div class="hud-top">
        <div class="hud-box">
            <span id="coin-icon">$</span>
            <span>é‡‘å¸</span>
            <span id="score" class="hud-value">200</span>
        </div>
    </div>

    <div id="toast">é‡‘å¸ä¸è¶³ï¼</div>

    <!-- ä¼˜åŒ–åçš„åº•éƒ¨å¸ƒå±€ï¼šå·¦å³æŒ‰é’®ï¼Œä¸­é—´ç‚®å° -->
    <div class="controls-bottom">
        <div class="btn-change" onclick="changeCannon(-1, event)">âˆ’</div>
            <div class="btn-change" onclick="changeCannon(1, event)">+</div>
        </div>

    <!-- æš‚åœç•Œé¢ -->
    <div class="overlay hidden" id="pauseScreen">
        <div style="font-size: 60px; margin-bottom: 15px;">â¸ï¸</div>
        <div class="pause-title">æ¸¸æˆæš‚åœ</div>
        <div class="pause-buttons">
            <button class="pause-btn-action continue" onclick="resumeGame()">ğŸ’– ç»§ç»­æ¸¸æˆ</button>
            <button class="pause-btn-action quit" onclick="quitGame()">ğŸ’¤ é€€å‡ºæ¸¸æˆ</button>
        </div>
    </div>
    
    <!-- æš‚åœæŒ‰é’® -->
    <button class="pause-btn hidden" id="pauseBtn" onclick="pauseGame()">âšâš</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    /**
     * æ•é±¼å¤§äº¨ - å®Œæ•´ç‰ˆ
     */

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const scoreEl = document.getElementById('score');
    const toastEl = document.getElementById('toast');

    // èƒŒæ™¯å›¾
    const bgImage = new Image();
    let bgImageLoaded = false;
    let bgImageLoading = false;

    let isPlaying = false;
    let isPaused = false; // æš‚åœçŠ¶æ€
    let isBankrupt = false; // æ˜¯å¦ç ´äº§ï¼ˆæ¸¸æˆç»“æŸï¼‰
    let width, height;
    // ä» localStorage è¯»å–é‡‘å¸ï¼Œå¦‚æœæ²¡æœ‰åˆ™é»˜è®¤ä¸º200
    let score = parseInt(localStorage.getItem('fishingMaster_score') || '200', 10);
    let frameCount = 0;
    
    // ä¿å­˜æ¸¸æˆæ•°æ®åˆ° localStorage
    function saveGameData() {
        localStorage.setItem('fishingMaster_score', score.toString());
    }
    
    // åŠ è½½æ¸¸æˆæ•°æ®
    function loadGameData() {
        const savedScore = localStorage.getItem('fishingMaster_score');
        if (savedScore !== null) {
            score = parseInt(savedScore, 10);
        }
    }
    
    // æ¸¸æˆæŒ‘æˆ˜æœºåˆ¶
    let totalKills = 0; // æ€»å‡»æ€æ•°
    let lastBossTime = 0; // ä¸Šæ¬¡Bosså‡ºç°æ—¶é—´
    const BOSS_COOLDOWN = 30000; // Bosså†·å´æ—¶é—´ï¼ˆ30ç§’ï¼‰
    const BOSS_MIN_KILLS = 10; // è§£é”Bossæ‰€éœ€çš„æœ€å°å‡»æ€æ•°
    let bossWarningActive = false; // Bossè­¦å‘Šæ˜¯å¦æ¿€æ´»
    let bossWarningTime = 0; // Bossè­¦å‘Šæ˜¾ç¤ºæ—¶é—´

    const input = { x: 0, y: 0 };
    let currentCannonLvl = 1;
    const MAX_CANNON_LVL = 5;
    const CANNON_COSTS = [0, 10, 20, 50, 100, 200];

    // å¯¹è±¡æ± 
    const pool = {
        bullets: [], particles: [], texts: [], webs: [],
        get: function(list, classType, ...args) {
            const item = list.find(i => !i.active);
            if (item) { item.reset(...args); return item; }
            const newItem = new classType(...args); list.push(newItem); return newItem;
        }
    };

    const entities = { bullets: [], fishes: [], particles: [], floatTexts: [], webs: [], ripples: [] };

    const FISH_TYPES = [
        { id: 0, name: "å°ä¸‘é±¼", color: '#FF4500', size: 12, speed: 2.5, score: 2, health: 0.8 },
        { id: 1, name: "çƒ­å¸¦é±¼", color: '#FFFF00', size: 18, speed: 2.0, score: 5, health: 1.5 },
        { id: 2, name: "è“å”ç‹", color: '#00FFFF', size: 25, speed: 1.5, score: 10, health: 3.0 },
        { id: 3, name: "ç¯ç¬¼é±¼", color: '#FF00FF', size: 35, speed: 1.2, score: 30, health: 8.0 },
        { id: 4, name: "æ·±æµ·å·¨é²¨", color: '#FF0000', size: 60, speed: 0.8, score: 100, health: 25.0 },
        { id: 5, name: "é‡‘é±¼", color: '#FFD700', size: 15, speed: 2.2, score: 3, health: 1.0 },
        { id: 6, name: "å‰‘é±¼", color: '#C0C0C0', size: 30, speed: 3.0, score: 15, health: 4.0 },
        { id: 7, name: "è´è¶é±¼", color: '#FF69B4', size: 20, speed: 1.8, score: 8, health: 2.5 },
        { id: 8, name: "æµ·è±š", color: '#708090', size: 28, speed: 2.8, score: 20, health: 5.0 },
        { id: 9, name: "æ°´æ¯", color: '#E6E6FA', size: 22, speed: 1.0, score: 12, health: 3.5 }
    ];

    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();
    
    // æ£€æµ‹å±å¹•æ–¹å‘å¹¶æ˜¾ç¤ºæç¤ºï¼ˆæ¨ªå±æ¸¸æˆï¼‰
    function checkOrientation() {
        const rotateWarning = document.getElementById('rotateWarning');
        if (!rotateWarning) return;
        
        const isPortrait = window.innerHeight > window.innerWidth;
        const isTabletSize = Math.max(window.innerWidth, window.innerHeight) >= 600;
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        
        // å¦‚æœæ˜¯è§¦å±è®¾å¤‡ä¸”ç«–å±ï¼Œæ˜¾ç¤ºæ—‹è½¬æç¤º
        if (isTouchDevice && isPortrait && isTabletSize) {
            rotateWarning.style.display = 'flex';
        } else {
            rotateWarning.style.display = 'none';
        }
    }
    
    // ç›‘å¬å±å¹•æ–¹å‘å˜åŒ–
    window.addEventListener('orientationchange', () => {
        setTimeout(() => {
            checkOrientation();
            resize();
        }, 100);
    });
    window.addEventListener('resize', () => {
        checkOrientation();
        resize();
    });
    
    // åˆå§‹æ£€æŸ¥
    checkOrientation();

    // åŠ è½½èƒŒæ™¯å›¾
    function loadBackgroundImage() {
        if (bgImageLoading || bgImageLoaded) return;
        bgImageLoading = true;
        
        // å°è¯•ä»å¤–éƒ¨æ–‡ä»¶åŠ è½½
        if (typeof BG_IMAGE_BASE64 !== 'undefined') {
            bgImage.src = BG_IMAGE_BASE64;
        } else {
            // å¦‚æœæ²¡æœ‰å¤–éƒ¨æ–‡ä»¶ï¼Œä½¿ç”¨æ¸å˜èƒŒæ™¯
            bgImageLoaded = true;
            bgImageLoading = false;
            return;
        }
        
        bgImage.onload = function() {
            bgImageLoaded = true;
            bgImageLoading = false;
            console.log('èƒŒæ™¯å›¾ç‰‡åŠ è½½æˆåŠŸ');
            // å¦‚æœé¦–é¡µåŠ¨ç”»æ­£åœ¨è¿è¡Œï¼Œé‡æ–°ç»˜åˆ¶ä¸€å¸§ä»¥ç¡®ä¿èƒŒæ™¯å›¾æ˜¾ç¤º
            if (hpAnimationId) {
                homepageAnimationLoop();
            }
        };
        
        bgImage.onerror = function() {
            bgImageLoaded = true;
            bgImageLoading = false;
            console.log('èƒŒæ™¯å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨æ¸å˜èƒŒæ™¯');
        };
    }
    
    // é¡µé¢åŠ è½½æ—¶ç«‹å³å°è¯•åŠ è½½èƒŒæ™¯å›¾ï¼ˆåœ¨é¦–é¡µåŠ¨ç”»å¯åŠ¨å‰ï¼‰
    if (typeof BG_IMAGE_BASE64 !== 'undefined') {
        loadBackgroundImage();
    }

    window.startGame = function() {
        // åŠ è½½ä¿å­˜çš„æ¸¸æˆæ•°æ®
        loadGameData();
        
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('ui-layer').style.display = 'block';
        isPlaying = true;
        isPaused = false;
        // é‡ç½®æ¸¸æˆç»Ÿè®¡
        totalKills = 0;
        lastBossTime = 0;
        bossWarningActive = false;
        bossWarningTime = 0;
        // åªæœ‰ç ´äº§æ—¶æ‰é‡ç½®é‡‘å¸ï¼Œå¦åˆ™ä¿æŒå½“å‰é‡‘å¸
        if (isBankrupt) {
            score = 200; // ç ´äº§åé‡ç½®é‡‘å¸
            currentCannonLvl = 1; // é‡ç½®ç‚®å°ç­‰çº§
            isBankrupt = false; // é‡ç½®ç ´äº§æ ‡è®°
            saveGameData(); // ä¿å­˜é‡ç½®åçš„é‡‘å¸
        }
        // å¦‚æœé‡‘å¸ä¸è¶³æœ€ä½ç­‰çº§è´¹ç”¨ï¼Œé‡ç½®ä¸º200
        const minCost = CANNON_COSTS[1];
        if (score < minCost) {
            score = 200;
            currentCannonLvl = 1;
            saveGameData(); // ä¿å­˜é‡ç½®åçš„é‡‘å¸
        }
        updateScoreUI();
        // æ˜¾ç¤ºæš‚åœæŒ‰é’®
        document.getElementById('pauseBtn').classList.remove('hidden');
        resize();
        loadBackgroundImage();
        loop();
    };

    function endGame() {
        isPlaying = false;
        isPaused = false;
        isBankrupt = true; // æ ‡è®°ä¸ºç ´äº§
        const startScreen = document.getElementById('start-screen');
        startScreen.style.display = 'flex'; // ä½¿ç”¨ flex ä¿æŒå±…ä¸­å¸ƒå±€
        document.getElementById('ui-layer').style.display = 'none';
        // éšè—æš‚åœæŒ‰é’®
        document.getElementById('pauseBtn').classList.add('hidden');
        document.getElementById('pauseScreen').classList.add('hidden');
        showToast("æ¸¸æˆç»“æŸï¼é‡‘å¸ä¸è¶³", 3000);
    }

    // æš‚åœæ¸¸æˆ
    window.pauseGame = function() {
        if (!isPlaying || isPaused) return;
        isPaused = true;
        document.getElementById('pauseScreen').classList.remove('hidden');
        document.getElementById('pauseBtn').classList.add('hidden');
    };
    
    // ç»§ç»­æ¸¸æˆ
    window.resumeGame = function() {
        if (!isPaused) return;
        isPaused = false;
        document.getElementById('pauseScreen').classList.add('hidden');
        document.getElementById('pauseBtn').classList.remove('hidden');
    };
    
    // é€€å‡ºæ¸¸æˆï¼ˆæš‚åœé€€å‡ºï¼Œä¿å­˜é‡‘å¸ï¼‰
    window.quitGame = function() {
        isPlaying = false;
        isPaused = false;
        // ä¸è®¾ç½® isBankruptï¼Œä¿æŒå½“å‰é‡‘å¸
        document.getElementById('pauseScreen').classList.add('hidden');
        document.getElementById('pauseBtn').classList.add('hidden');
        const startScreen = document.getElementById('start-screen');
        startScreen.style.display = 'flex';
        document.getElementById('ui-layer').style.display = 'none';
    };

    function updateInput(cx, cy) {
        const rect = canvas.getBoundingClientRect();
        input.x = cx - rect.left;
        input.y = cy - rect.top;
    }

    window.changeCannon = function(dir, e) {
        // é˜»æ­¢äº‹ä»¶ä¼ æ’­ï¼Œé˜²æ­¢è§¦å‘å…¶ä»–äº‹ä»¶å¤„ç†
        if (e) {
            e.stopPropagation();
            e.preventDefault();
        }
        currentCannonLvl += dir;
        if (currentCannonLvl < 1) currentCannonLvl = 1;
        if (currentCannonLvl > MAX_CANNON_LVL) currentCannonLvl = MAX_CANNON_LVL;
        // ç­‰çº§æ•°å­—ç°åœ¨ç›´æ¥æ˜¾ç¤ºåœ¨ç‚®å°ä¸Šï¼Œæ— éœ€æ›´æ–°DOM
        if(navigator.vibrate) navigator.vibrate(20);
    };

    window.addEventListener('wheel', e => changeCannon(e.deltaY < 0 ? 1 : -1));

    let lastShootTime = 0;
    const SHOOT_COOLDOWN = 150; // å°„å‡»å†·å´æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰

    function handleShoot(e) {
        if(!isPlaying) return;
        
        // é˜²æŠ–ï¼šé˜²æ­¢çŸ­æ—¶é—´å†…é‡å¤å°„å‡»
        const now = Date.now();
        if(now - lastShootTime < SHOOT_COOLDOWN) return;
        lastShootTime = now;
        
        // é˜²æ­¢ç‚¹å‡»åº•éƒ¨æŒ‰é’®æ—¶ä¹Ÿå‘å°„
        if(input.y > height - 80 && (input.x < width/2 - 80 || input.x > width/2 + 80)) return;

        const cost = CANNON_COSTS[currentCannonLvl];
        if(score >= cost) {
            score -= cost;
            updateScoreUI();
            shoot();
            entities.ripples.push(new Ripple(input.x, input.y));
        } else {
            showToast("é‡‘å¸ä¸è¶³ï¼");
        }
    }

    window.addEventListener('mousedown', e => { 
        // å¦‚æœç‚¹å‡»çš„æ˜¯æŒ‰é’®ï¼Œä¸å¤„ç†
        if (e.target.closest('button, .btn-change')) return;
        updateInput(e.clientX, e.clientY); 
        handleShoot(); 
    });
    window.addEventListener('mousemove', e => {
        // å¦‚æœé¼ æ ‡åœ¨æŒ‰é’®ä¸Šï¼Œä¸æ›´æ–°è¾“å…¥ä½ç½®ï¼ˆé˜²æ­¢ç‚®å°è½¬å‘ï¼‰
        if (e.target.closest('button, .btn-change')) return;
        updateInput(e.clientX, e.clientY);
    });
    window.addEventListener('touchstart', e => { 
        // å¦‚æœç‚¹å‡»çš„æ˜¯æŒ‰é’®ï¼Œä¸é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œå…è®¸æ­£å¸¸ç‚¹å‡»
        if (e.target.closest('button, .btn-change')) return;
        e.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œé˜²æ­¢è§¦å‘ mousedown
        updateInput(e.touches[0].clientX, e.touches[0].clientY); 
        handleShoot(); 
    }, {passive: false});
    window.addEventListener('touchmove', e => { 
        // å¦‚æœè§¦æ‘¸çš„æ˜¯æŒ‰é’®åŒºåŸŸï¼Œä¸é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œä¹Ÿä¸æ›´æ–°è¾“å…¥ä½ç½®
        if (e.target.closest('button, .btn-change')) return;
        e.preventDefault(); 
        updateInput(e.touches[0].clientX, e.touches[0].clientY); 
    }, {passive: false});

    function updateScoreUI() { 
        scoreEl.innerText = Math.floor(score);
        updateHomepageScore(); // åŒæ—¶æ›´æ–°é¦–é¡µé‡‘å¸æ˜¾ç¤º
        saveGameData(); // æ¯æ¬¡æ›´æ–°UIæ—¶ä¿å­˜æ•°æ®
    }
    function showToast(msg, duration = 1500) { 
        toastEl.innerText = msg; 
        toastEl.style.opacity = 1; 
        setTimeout(() => toastEl.style.opacity = 0, duration); 
    }
    
    // æ›´æ–°Bossè­¦å‘Šæ˜¾ç¤º
    function updateBossWarning() {
        if (bossWarningActive && bossWarningTime > 0) {
            bossWarningTime -= 16; // æ¯å¸§å‡å°‘ï¼ˆå‡è®¾60fpsï¼‰
            if (bossWarningTime <= 0) {
                bossWarningActive = false;
            }
        }
    }

    // Classes
    class Ripple {
        constructor(x, y) { this.x=x; this.y=y; this.r=0; this.active=true; this.opacity=1; }
        update() { this.r+=4; this.opacity-=0.05; if(this.opacity<=0) this.active=false; }
        draw(ctx) { ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.strokeStyle = `rgba(100,255,255,${this.opacity})`; ctx.lineWidth=2; ctx.stroke(); }
    }

    const cannon = {
        x: 0, y: 0, angle: 0, recoil: 0, animTime: 0,
        update: function() {
            this.x = width / 2;
            this.y = height - 30; // ä¸Šç§»ï¼Œä¸æŒ‰é’®å¯¹é½
            const dx = input.x - this.x;
            const dy = input.y - this.y;
            this.angle = Math.atan2(dy, dx) - Math.PI / 2;
            if (this.recoil > 0) this.recoil -= 1;
            this.animTime += 0.12; // åŠ¨ç”»è®¡æ—¶
        },
        draw: function(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            
            // ç²‰è‰²é±¼å›ºå®šé¢œè‰²ï¼ˆä¸å†æ ¹æ®ç­‰çº§å˜åŒ–ï¼‰
            const baseColor = '#ff69b4';
            const darkColor = '#c71585';
            const lightColor = '#ffb6d9';
            
            // åŠ¨ç”»æ•ˆæœ
            const swimWave = Math.sin(this.animTime) * 0.08; // æ‘†å°¾
            const breathe = 1 + Math.sin(this.animTime * 0.6) * 0.025; // å‘¼å¸
            const finWave = Math.sin(this.animTime * 1.8) * 0.25; // é³æ‘†åŠ¨
            
            // æ ¹æ®ç­‰çº§ç¡®å®šå¤§å°ï¼ˆé¢œè‰²ä¸å˜ï¼‰
            const sc = 0.85 + (currentCannonLvl - 1) * 0.05; // ç­‰çº§è¶Šé«˜é±¼è¶Šå¤§ï¼ŒåŸºç¡€å¤§å°å¢å¤§
            
            // å¤–å±‚å…‰æ™•
            ctx.shadowColor = '#ff69b4';
            ctx.shadowBlur = 15;
            
            // å…ˆç¿»è½¬180åº¦ï¼Œè®©å°¾å·´åœ¨åº•éƒ¨
            ctx.rotate(Math.PI);
            
            // é±¼èº«ä¸»ä½“æ¸å˜ï¼ˆç²‰è‰²ï¼‰
            const bodyGrad = ctx.createRadialGradient(0, -8 * sc, 0, 0, 0, 28 * sc);
            bodyGrad.addColorStop(0, '#ffb6d9');
            bodyGrad.addColorStop(0.3, '#ff69b4');
            bodyGrad.addColorStop(0.7, '#ff1493');
            bodyGrad.addColorStop(1, '#c71585');
            
            // é±¼å°¾ï¼ˆå¸¦æ‘†åŠ¨ï¼‰- ç°åœ¨åœ¨åº•éƒ¨
            ctx.save();
            ctx.rotate(swimWave);
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.moveTo(0, 20 * sc);
            ctx.quadraticCurveTo(-10 * sc, 28 * sc, -15 * sc, 40 * sc);
            ctx.quadraticCurveTo(0, 34 * sc, 15 * sc, 40 * sc);
            ctx.quadraticCurveTo(10 * sc, 28 * sc, 0, 20 * sc);
            ctx.fill();
            ctx.restore();
            
            // é±¼èº«æ¤­åœ†ï¼ˆå¸¦å‘¼å¸ï¼‰
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 18 * sc * breathe, 26 * sc, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // è…¹éƒ¨é«˜å…‰
            ctx.fillStyle = 'rgba(255,220,240,0.5)';
            ctx.beginPath();
            ctx.ellipse(3 * sc, 8 * sc, 10 * sc, 14 * sc, 0.15, 0, Math.PI * 2);
            ctx.fill();
            
            // ä¾§é³ï¼ˆå¸¦æ‘†åŠ¨ï¼‰
            ctx.fillStyle = bodyGrad;
            // å·¦ä¾§é³
            ctx.save();
            ctx.translate(-16 * sc, 3 * sc);
            ctx.rotate(-0.4 + finWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, 14 * sc, 5 * sc, -0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            // å³ä¾§é³
            ctx.save();
            ctx.translate(16 * sc, 3 * sc);
            ctx.rotate(0.4 - finWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, 14 * sc, 5 * sc, 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // ç™½è‰²æ¡çº¹
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.beginPath();
            ctx.ellipse(-6 * sc, -2 * sc, 2.5 * sc, 18 * sc, -0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(6 * sc, -2 * sc, 2.5 * sc, 18 * sc, 0.1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0;
            
            // çœ¼ç›å¤–æ¡†ï¼ˆç°åœ¨åœ¨ä¸‹æ–¹ï¼Œå› ä¸ºç¿»è½¬äº†ï¼‰
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(-7 * sc, -10 * sc, 7 * sc, 6 * sc, 0, 0, Math.PI * 2);
            ctx.ellipse(7 * sc, -10 * sc, 7 * sc, 6 * sc, 0, 0, Math.PI * 2);
            ctx.fill();
            // çœ¼çƒ
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(-7 * sc, -9 * sc, 3.5 * sc, 0, Math.PI * 2);
            ctx.arc(7 * sc, -9 * sc, 3.5 * sc, 0, Math.PI * 2);
            ctx.fill();
            // çœ¼ç›é«˜å…‰
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-8.5 * sc, -11 * sc, 2 * sc, 0, Math.PI * 2);
            ctx.arc(5.5 * sc, -11 * sc, 2 * sc, 0, Math.PI * 2);
            ctx.fill();
            // ç¬¬äºŒå±‚é«˜å…‰
            ctx.beginPath();
            ctx.arc(-5.5 * sc, -8 * sc, 1 * sc, 0, Math.PI * 2);
            ctx.arc(8.5 * sc, -8 * sc, 1 * sc, 0, Math.PI * 2);
            ctx.fill();
            
            // å˜´å·´ï¼ˆå¾®ç¬‘ï¼‰- ç°åœ¨åœ¨ä¸‹æ–¹
            ctx.strokeStyle = '#c71585';
            ctx.lineWidth = 2 * sc;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, -16 * sc, 4 * sc, 0.15 * Math.PI, 0.85 * Math.PI);
            ctx.stroke();
            
            // è„¸é¢šçº¢æ™•
            ctx.fillStyle = 'rgba(255,100,150,0.3)';
            ctx.beginPath();
            ctx.ellipse(-14 * sc, -6 * sc, 4 * sc, 2.5 * sc, 0, 0, Math.PI * 2);
            ctx.ellipse(14 * sc, -6 * sc, 4 * sc, 2.5 * sc, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // é³ç‰‡çº¹ç†
            ctx.strokeStyle = 'rgba(255,255,255,0.2)';
            ctx.lineWidth = 0.8 * sc;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.arc(0, (2 + i * 5) * sc, (12 - i * 2) * sc, 0.65 * Math.PI, 0.35 * Math.PI, true);
                ctx.stroke();
            }
            
            // === åœ¨é±¼èº«ä¸­å¿ƒç»˜åˆ¶ç­‰çº§æ•°å­—ï¼ˆé‡‘è‰²ï¼‰ ===
            ctx.fillStyle = '#FFD700';
            ctx.font = 'bold ' + (20 + currentCannonLvl * 2) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // æ•°å­—é˜´å½±ï¼ˆå¢å¼ºç«‹ä½“æ„Ÿï¼‰
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillText(currentCannonLvl, 1, 1);
            ctx.fillStyle = '#FFD700';
            ctx.fillText(currentCannonLvl, 0, 0);
            
            ctx.restore();
        }
    };

    class Bullet {
        constructor() { this.active = false; }
        reset(x, y, angle, level) {
            this.x = x; this.y = y; this.level = level;
            const moveAngle = angle + Math.PI / 2;
            this.vx = Math.cos(moveAngle) * 12; this.vy = Math.sin(moveAngle) * 12;
            this.active = true; this.drawAngle = angle;
        }
        update() {
            if (!this.active) return;
            this.x += this.vx; this.y += this.vy;
            if (this.x < -50 || this.x > width+50 || this.y < -50 || this.y > height+50) this.active = false;
        }
        draw(ctx) {
            if (!this.active) return;
            ctx.save(); 
            ctx.translate(this.x, this.y); 
            ctx.rotate(this.drawAngle);
            
            // æ ¹æ®ç­‰çº§ç¡®å®šé¢œè‰²
            let bubbleColor, strokeColor, innerColor;
            switch(this.level) {
                case 1:
                    bubbleColor = 'rgba(100, 200, 255, 0.6)'; // è“è‰²
                    strokeColor = 'rgba(200, 240, 255, 0.9)';
                    innerColor = 'rgba(150, 220, 255, 0.4)';
                    break;
                case 2:
                    bubbleColor = 'rgba(100, 255, 200, 0.6)'; // é’è‰²
                    strokeColor = 'rgba(200, 255, 240, 0.9)';
                    innerColor = 'rgba(150, 255, 220, 0.4)';
                    break;
                case 3:
                    bubbleColor = 'rgba(200, 150, 255, 0.6)'; // ç´«è‰²
                    strokeColor = 'rgba(240, 200, 255, 0.9)';
                    innerColor = 'rgba(220, 150, 255, 0.4)';
                    break;
                case 4:
                    bubbleColor = 'rgba(255, 150, 200, 0.6)'; // ç²‰ç´«è‰²
                    strokeColor = 'rgba(255, 200, 240, 0.9)';
                    innerColor = 'rgba(255, 150, 220, 0.4)';
                    break;
                case 5:
                    bubbleColor = 'rgba(255, 215, 0, 0.7)'; // é‡‘è‰²
                    strokeColor = 'rgba(255, 240, 150, 0.9)';
                    innerColor = 'rgba(255, 200, 100, 0.5)';
                    break;
                default:
                    bubbleColor = 'rgba(100, 200, 255, 0.6)';
                    strokeColor = 'rgba(200, 240, 255, 0.9)';
                    innerColor = 'rgba(150, 220, 255, 0.4)';
            }
            
            // æ°´æ³¡å­å¼¹è®¾è®¡
            const r = 6 + this.level * 1.5; // æ ¹æ®ç­‰çº§è°ƒæ•´å¤§å°
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fillStyle = bubbleColor;
            ctx.fill();
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // é«˜å…‰
            ctx.beginPath();
            ctx.arc(-2, -2, r * 0.3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fill();
            
            // å†…éƒ¨æ°”æ³¡æ•ˆæœ
            ctx.beginPath();
            ctx.arc(-r * 0.3, -r * 0.3, r * 0.4, 0, Math.PI * 2);
            ctx.fillStyle = innerColor;
            ctx.fill();
            
            ctx.restore();
        }
    }

    class Web {
        constructor() { this.active = false; }
        reset(x, y, level) {
            this.x = x; this.y = y; this.level = level;
            this.scale = 0; this.life = 15; this.active = true; this.r = 60 + level * 15;
            checkAreaCatch(this);
        }
        update() { if(this.scale < 1) this.scale += 0.2; this.life--; if(this.life <= 0) this.active = false; }
        draw(ctx) {
            if (!this.active) return;
            ctx.save(); ctx.translate(this.x, this.y); ctx.scale(this.scale, this.scale);
            const color = this.level >= 5 ? '255, 215, 0' : (this.level >=3 ? '255, 0, 255' : '0, 255, 255');
            ctx.beginPath(); ctx.arc(0,0, this.r, 0, Math.PI*2);
            ctx.strokeStyle = `rgba(${color}, 0.8)`; ctx.lineWidth = 2; ctx.stroke();
            ctx.fillStyle = `rgba(${color}, 0.1)`; ctx.fill();
            ctx.beginPath(); for(let i=0; i<4; i++) { ctx.rotate(Math.PI/4); ctx.moveTo(0,0); ctx.lineTo(0, this.r); } ctx.stroke();
            ctx.restore();
        }
    }

    class Fish {
        constructor() { this.reset(); }
        reset(fishTypeIndex = null) {
            // å¦‚æœæŒ‡å®šäº†é±¼çš„ç±»å‹ï¼Œä½¿ç”¨æŒ‡å®šçš„ï¼›å¦åˆ™æ ¹æ®æœºåˆ¶éšæœºç”Ÿæˆ
            if (fishTypeIndex !== null && fishTypeIndex >= 0 && fishTypeIndex < FISH_TYPES.length) {
                this.type = FISH_TYPES[fishTypeIndex];
            } else {
                this.type = this.selectRandomFishType();
            }
            // æ¯æ¡é±¼çš„è¡€é‡åœ¨åŸºç¡€è¡€é‡çš„70%-130%ä¹‹é—´éšæœº
            const baseHealth = this.type.health;
            const healthVariation = 0.3; // 30%çš„å˜åŒ–èŒƒå›´
            this.health = baseHealth * (1 - healthVariation / 2 + Math.random() * healthVariation);
            
            const fromLeft = Math.random() > 0.5;
            this.x = fromLeft ? -60 : width + 60; this.y = Math.random() * (height - 100) + 50;
            let angle = fromLeft ? (Math.random()*0.5 - 0.25) : (Math.PI + Math.random()*0.5 - 0.25);
            this.vx = Math.cos(angle) * this.type.speed; this.vy = Math.sin(angle) * this.type.speed;
            this.angle = Math.atan2(this.vy, this.vx);
            this.active = true; 
            this.frame = Math.random() * 100; 
            this.wobble = Math.random() * 0.1;
            this.tailWag = 0; // å°¾å·´æ‘†åŠ¨
            this.finWag = 0; // é±¼é³æ‘†åŠ¨
        }
        
        // æ ¹æ®æŒ‘æˆ˜æœºåˆ¶é€‰æ‹©é±¼çš„ç±»å‹
        selectRandomFishType() {
            const now = Date.now();
            const canSpawnBoss = totalKills >= BOSS_MIN_KILLS && 
                                 (now - lastBossTime) >= BOSS_COOLDOWN &&
                                 entities.fishes.filter(f => f.active && f.type.id === 4).length === 0; // ç¡®ä¿åŒæ—¶åªæœ‰ä¸€ä¸ªBoss
            
            // å¦‚æœæ»¡è¶³Bossç”Ÿæˆæ¡ä»¶ï¼Œæœ‰æ›´é«˜æ¦‚ç‡ç”ŸæˆBoss
            if (canSpawnBoss && Math.random() < 0.15) { // 15%æ¦‚ç‡å¼ºåˆ¶ç”ŸæˆBoss
                // è§¦å‘Bossè­¦å‘Š
                bossWarningActive = true;
                bossWarningTime = 3000; // æ˜¾ç¤º3ç§’
                lastBossTime = now;
                showToast("âš ï¸ æ·±æµ·å·¨é²¨å‡ºç°ï¼", 3000);
                return FISH_TYPES[4]; // ç›´æ¥è¿”å›Bossç±»å‹
            }
            
            // ç”Ÿæˆæƒé‡æ•°ç»„
            const weights = [];
            let totalWeight = 0;
            
            for (let i = 0; i < FISH_TYPES.length; i++) {
                let weight = 0;
                
                if (i === 0) { // å°ä¸‘é±¼ - æœ€å¸¸è§
                    weight = 35;
                } else if (i === 1) { // çƒ­å¸¦é±¼
                    weight = 25;
                } else if (i === 2) { // è“å”ç‹
                    weight = 18;
                } else if (i === 3) { // ç¯ç¬¼é±¼
                    weight = 7;
                    // éœ€è¦è‡³å°‘å‡»æ€5æ¡é±¼æ‰èƒ½å‡ºç°
                    if (totalKills < 5) weight = 0;
                } else if (i === 4) { // æ·±æµ·å·¨é²¨ - Bossï¼ˆä¸åœ¨å¼ºåˆ¶ç”Ÿæˆæ—¶æ‰ä¼šéšæœºï¼‰
                    weight = 0; // ä¸åœ¨éšæœºæ± ä¸­ï¼Œåªèƒ½é€šè¿‡å¼ºåˆ¶ç”Ÿæˆ
                } else if (i === 5) { // é‡‘é±¼
                    weight = 15;
                } else if (i === 6) { // å‰‘é±¼
                    weight = 10;
                    // éœ€è¦è‡³å°‘å‡»æ€3æ¡é±¼æ‰èƒ½å‡ºç°
                    if (totalKills < 3) weight = 0;
                } else if (i === 7) { // è´è¶é±¼
                    weight = 12;
                } else if (i === 8) { // æµ·è±š
                    weight = 8;
                    // éœ€è¦è‡³å°‘å‡»æ€7æ¡é±¼æ‰èƒ½å‡ºç°
                    if (totalKills < 7) weight = 0;
                } else if (i === 9) { // æ°´æ¯
                    weight = 6;
                    // éœ€è¦è‡³å°‘å‡»æ€4æ¡é±¼æ‰èƒ½å‡ºç°
                    if (totalKills < 4) weight = 0;
                }
                
                weights.push(weight);
                totalWeight += weight;
            }
            
            // æ ¹æ®æƒé‡éšæœºé€‰æ‹©
            let random = Math.random() * totalWeight;
            for (let i = 0; i < weights.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    return FISH_TYPES[i];
                }
            }
            
            // é»˜è®¤è¿”å›å°ä¸‘é±¼
            return FISH_TYPES[0];
        }
        update() {
            if (!this.active) return;
            this.x += this.vx; this.y += this.vy; 
            this.frame += 0.1 + this.wobble;
            this.tailWag = Math.sin(this.frame * 0.2) * 0.4;
            this.finWag = Math.cos(this.frame * 0.15) * 0.3;
            if (this.x < -100 || this.x > width + 100) this.active = false;
        }
        draw(ctx) {
            if (!this.active) return;
            ctx.save(); 
            ctx.translate(this.x, this.y); 
            ctx.rotate(this.angle);
            
            const s = this.type.size;
            const bodyWave = Math.sin(this.frame * 0.12) * 0.05;
            const fishId = this.type.id;
            
            // æ ¹æ®é±¼çš„ç±»å‹ç»˜åˆ¶ä¸åŒçš„ç‰¹å¾
            this.drawFishByType(ctx, s, bodyWave, fishId);
            
            ctx.restore();
        }
        
        // æ ¹æ®ä¸åŒç±»å‹ç»˜åˆ¶ç‹¬ç‰¹çš„é±¼
        drawFishByType(ctx, s, bodyWave, fishId) {
            switch(fishId) {
                case 0: // å°ä¸‘é±¼ - æ©™è‰²æ¡çº¹
                    this.drawClownfish(ctx, s, bodyWave);
                    break;
                case 1: // çƒ­å¸¦é±¼ - é»„è‰²ï¼Œå¤§å°¾å·´
                    this.drawTropicalFish(ctx, s, bodyWave);
                    break;
                case 2: // è“å”ç‹ - è“è‰²ï¼Œä¼˜é›…
                    this.drawBlueTang(ctx, s, bodyWave);
                    break;
                case 3: // ç¯ç¬¼é±¼ - ç´«è‰²ï¼Œå‘å…‰
                    this.drawLanternFish(ctx, s, bodyWave);
                    break;
                case 4: // æ·±æµ·å·¨é²¨ - çº¢è‰²ï¼Œå‡¶çŒ›
                    this.drawShark(ctx, s, bodyWave);
                    break;
                case 5: // é‡‘é±¼ - é‡‘è‰²
                    this.drawGoldfish(ctx, s, bodyWave);
                    break;
                case 6: // å‰‘é±¼ - é“¶è‰²ï¼Œé•¿å˜´
                    this.drawSwordfish(ctx, s, bodyWave);
                    break;
                case 7: // è´è¶é±¼ - å¤šå½©
                    this.drawButterflyFish(ctx, s, bodyWave);
                    break;
                case 8: // æµ·è±š - ç°è‰²ï¼Œå¿«é€Ÿ
                    this.drawDolphin(ctx, s, bodyWave);
                    break;
                case 9: // æ°´æ¯ - é€æ˜ï¼Œå‘å…‰
                    this.drawJellyfish(ctx, s, bodyWave);
                    break;
                default:
                    this.drawDefaultFish(ctx, s, bodyWave);
            }
        }
        
        // å°ä¸‘é±¼ - æ©™è‰²æ¡çº¹ï¼Œåœ†æ¶¦
        drawClownfish(ctx, s, bodyWave) {
            // å°¾å·´
            ctx.save();
            ctx.translate(-s * 0.65, 0);
            ctx.rotate(this.tailWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-s * 0.7, -s * 0.4, -s * 1.0, -s * 0.5);
            ctx.quadraticCurveTo(-s * 1.2, 0, -s * 1.0, s * 0.5);
            ctx.quadraticCurveTo(-s * 0.7, s * 0.4, 0, 0);
            ctx.closePath();
            const tailGrad = ctx.createLinearGradient(-s * 1.0, 0, 0, 0);
            tailGrad.addColorStop(0, '#FF8C00');
            tailGrad.addColorStop(1, '#FF4500');
            ctx.fillStyle = tailGrad;
            ctx.fill();
            ctx.restore();
            
            // èº«ä½“ - åœ†æ¶¦
            ctx.save();
            ctx.rotate(bodyWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 1.0, s * 0.7, 0, 0, Math.PI * 2);
            const bodyGrad = ctx.createRadialGradient(-s * 0.3, -s * 0.2, 0, 0, 0, s * 1.0);
            bodyGrad.addColorStop(0, '#FFD700');
            bodyGrad.addColorStop(0.5, '#FF4500');
            bodyGrad.addColorStop(1, '#FF6347');
            ctx.fillStyle = bodyGrad;
            ctx.fill();
            
            // ç™½è‰²æ¡çº¹
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-s * 0.3, -s * 0.2);
            ctx.lineTo(-s * 0.3, s * 0.2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(s * 0.1, -s * 0.25);
            ctx.lineTo(s * 0.1, s * 0.25);
            ctx.stroke();
            
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
            
            // é±¼é³
            this.drawFins(ctx, s, '#FF6347');
            
            // çœ¼ç›
            this.drawEye(ctx, s * 0.35, -s * 0.12);
        }
        
        // çƒ­å¸¦é±¼ - é»„è‰²ï¼Œå¤§å°¾å·´
        drawTropicalFish(ctx, s, bodyWave) {
            // å¤§å°¾å·´
            ctx.save();
            ctx.translate(-s * 0.6, 0);
            ctx.rotate(this.tailWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-s * 1.0, -s * 0.6, -s * 1.5, -s * 0.7);
            ctx.quadraticCurveTo(-s * 1.8, 0, -s * 1.5, s * 0.7);
            ctx.quadraticCurveTo(-s * 1.0, s * 0.6, 0, 0);
            ctx.closePath();
            const tailGrad = ctx.createLinearGradient(-s * 1.5, 0, 0, 0);
            tailGrad.addColorStop(0, '#FFD700');
            tailGrad.addColorStop(0.5, '#FFFF00');
            tailGrad.addColorStop(1, '#FFA500');
            ctx.fillStyle = tailGrad;
            ctx.fill();
            ctx.restore();
            
            // èº«ä½“
            ctx.save();
            ctx.rotate(bodyWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 1.1, s * 0.6, 0, 0, Math.PI * 2);
            const bodyGrad = ctx.createRadialGradient(-s * 0.3, -s * 0.2, 0, 0, 0, s * 1.1);
            bodyGrad.addColorStop(0, '#FFFF99');
            bodyGrad.addColorStop(0.5, '#FFFF00');
            bodyGrad.addColorStop(1, '#FFA500');
            ctx.fillStyle = bodyGrad;
            ctx.fill();
            
            // æ–‘ç‚¹
            ctx.fillStyle = '#FF8C00';
            ctx.beginPath();
            ctx.arc(-s * 0.2, 0, s * 0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(s * 0.2, -s * 0.1, s * 0.12, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#FF8C00';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
            
            // é±¼é³
            this.drawFins(ctx, s, '#FFA500');
            
            // çœ¼ç›
            this.drawEye(ctx, s * 0.4, -s * 0.1);
        }
        
        // è“å”ç‹ - è“è‰²ï¼Œä¼˜é›…
        drawBlueTang(ctx, s, bodyWave) {
            // å°¾å·´
            ctx.save();
            ctx.translate(-s * 0.7, 0);
            ctx.rotate(this.tailWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-s * 0.9, -s * 0.5, -s * 1.3, -s * 0.6);
            ctx.quadraticCurveTo(-s * 1.5, 0, -s * 1.3, s * 0.6);
            ctx.quadraticCurveTo(-s * 0.9, s * 0.5, 0, 0);
            ctx.closePath();
            const tailGrad = ctx.createLinearGradient(-s * 1.3, 0, 0, 0);
            tailGrad.addColorStop(0, '#00CED1');
            tailGrad.addColorStop(1, '#00FFFF');
            ctx.fillStyle = tailGrad;
            ctx.fill();
            ctx.restore();
            
            // èº«ä½“
            ctx.save();
            ctx.rotate(bodyWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 1.2, s * 0.65, 0, 0, Math.PI * 2);
            const bodyGrad = ctx.createRadialGradient(-s * 0.3, -s * 0.2, 0, 0, 0, s * 1.2);
            bodyGrad.addColorStop(0, '#87CEEB');
            bodyGrad.addColorStop(0.5, '#00FFFF');
            bodyGrad.addColorStop(1, '#008B8B');
            ctx.fillStyle = bodyGrad;
            ctx.fill();
            
            // é»‘è‰²æ¡çº¹
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(-s * 0.4, -s * 0.3);
            ctx.lineTo(s * 0.6, s * 0.3);
            ctx.stroke();
            
            ctx.strokeStyle = '#008B8B';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
            
            // é±¼é³
            this.drawFins(ctx, s, '#00CED1');
            
            // çœ¼ç›
            this.drawEye(ctx, s * 0.45, -s * 0.12);
        }
        
        // ç¯ç¬¼é±¼ - ç´«è‰²ï¼Œå‘å…‰
        drawLanternFish(ctx, s, bodyWave) {
            // å°¾å·´
            ctx.save();
            ctx.translate(-s * 0.7, 0);
            ctx.rotate(this.tailWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-s * 1.0, -s * 0.5, -s * 1.4, -s * 0.6);
            ctx.quadraticCurveTo(-s * 1.6, 0, -s * 1.4, s * 0.6);
            ctx.quadraticCurveTo(-s * 1.0, s * 0.5, 0, 0);
            ctx.closePath();
            const tailGrad = ctx.createLinearGradient(-s * 1.4, 0, 0, 0);
            tailGrad.addColorStop(0, '#BA55D3');
            tailGrad.addColorStop(1, '#FF00FF');
            ctx.fillStyle = tailGrad;
            ctx.fill();
            ctx.restore();
            
            // èº«ä½“
            ctx.save();
            ctx.rotate(bodyWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 1.3, s * 0.7, 0, 0, Math.PI * 2);
            const bodyGrad = ctx.createRadialGradient(-s * 0.3, -s * 0.2, 0, 0, 0, s * 1.3);
            bodyGrad.addColorStop(0, '#FFB6FF');
            bodyGrad.addColorStop(0.5, '#FF00FF');
            bodyGrad.addColorStop(1, '#8B008B');
            ctx.fillStyle = bodyGrad;
            ctx.fill();
            
            // å‘å…‰ç‚¹ - ä½¿ç”¨ç‹¬ç«‹çš„save/restoreç¡®ä¿ä¸å½±å“å…¶ä»–ç»˜åˆ¶
            ctx.save();
            const glowIntensity = 0.5 + Math.sin(this.frame * 0.3) * 0.3;
            ctx.globalAlpha = glowIntensity;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-s * 0.2, -s * 0.3, s * 0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(s * 0.3, 0, s * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore(); // æ¢å¤alphaçŠ¶æ€
            
            ctx.strokeStyle = '#8B008B';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
            
            // é±¼é³
            this.drawFins(ctx, s, '#BA55D3');
            
            // çœ¼ç›
            this.drawEye(ctx, s * 0.5, -s * 0.15);
        }
        
        // æ·±æµ·å·¨é²¨ - ç°è‰²ï¼Œå‡¶çŒ›ï¼Œæµçº¿å‹
        drawShark(ctx, s, bodyWave) {
            // å°¾é³ - ä¸å¯¹ç§°ï¼Œä¸Šå¶å¤§ä¸‹å¶å°
            ctx.save();
            ctx.translate(-s * 0.7, 0);
            ctx.rotate(this.tailWag * 0.6);
            // ä¸Šå¶ï¼ˆå¤§ï¼‰
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-s * 0.4, -s * 1.2, -s * 1.0, -s * 0.8);
            ctx.quadraticCurveTo(-s * 1.3, -s * 0.4, -s * 1.1, -s * 0.2);
            ctx.quadraticCurveTo(-s * 0.6, -s * 0.1, 0, 0);
            ctx.closePath();
            const tailGrad = ctx.createLinearGradient(-s * 1.1, 0, 0, 0);
            tailGrad.addColorStop(0, '#2C3E50');
            tailGrad.addColorStop(1, '#34495E');
            ctx.fillStyle = tailGrad;
            ctx.fill();
            // ä¸‹å¶ï¼ˆå°ï¼‰
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-s * 0.3, s * 0.5, -s * 0.7, s * 0.4);
            ctx.quadraticCurveTo(-s * 0.5, s * 0.2, 0, 0);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
            
            // èº«ä½“ - æµçº¿å‹ï¼Œç°è‰²æ¸å˜
            ctx.save();
            ctx.rotate(bodyWave);
            // ä¸»ä½“
            ctx.beginPath();
            ctx.moveTo(s * 0.8, 0);
            ctx.quadraticCurveTo(s * 0.6, -s * 0.3, s * 0.3, -s * 0.4);
            ctx.quadraticCurveTo(-s * 0.2, -s * 0.45, -s * 0.6, -s * 0.3);
            ctx.quadraticCurveTo(-s * 0.7, 0, -s * 0.6, s * 0.3);
            ctx.quadraticCurveTo(-s * 0.2, s * 0.45, s * 0.3, s * 0.4);
            ctx.quadraticCurveTo(s * 0.6, s * 0.3, s * 0.8, 0);
            ctx.closePath();
            const bodyGrad = ctx.createLinearGradient(-s * 0.6, 0, s * 0.8, 0);
            bodyGrad.addColorStop(0, '#34495E');
            bodyGrad.addColorStop(0.3, '#5D6D7E');
            bodyGrad.addColorStop(0.6, '#7F8C8D');
            bodyGrad.addColorStop(1, '#95A5A6');
            ctx.fillStyle = bodyGrad;
            ctx.fill();
            
            // è…¹éƒ¨ï¼ˆæµ…è‰²ï¼‰
            ctx.beginPath();
            ctx.moveTo(s * 0.5, 0);
            ctx.quadraticCurveTo(0, s * 0.2, -s * 0.4, s * 0.15);
            ctx.quadraticCurveTo(-s * 0.5, 0, -s * 0.4, -s * 0.15);
            ctx.quadraticCurveTo(0, -s * 0.2, s * 0.5, 0);
            ctx.closePath();
            const bellyGrad = ctx.createLinearGradient(0, -s * 0.2, 0, s * 0.2);
            bellyGrad.addColorStop(0, '#ECF0F1');
            bellyGrad.addColorStop(1, '#BDC3C7');
            ctx.fillStyle = bellyGrad;
            ctx.fill();
            
            // çš®è‚¤çº¹ç†ï¼ˆå°ç‚¹ï¼‰
            ctx.fillStyle = 'rgba(44, 62, 80, 0.3)';
            for(let i = 0; i < 8; i++) {
                const x = -s * 0.3 + (i * s * 0.15);
                const y = (Math.random() - 0.5) * s * 0.3;
                ctx.beginPath();
                ctx.arc(x, y, s * 0.03, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.strokeStyle = '#2C3E50';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
            
            // å°–é¼»å­/å˜´å·´
            ctx.save();
            ctx.translate(s * 0.8, 0);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(s * 0.3, -s * 0.15);
            ctx.lineTo(s * 0.3, s * 0.15);
            ctx.closePath();
            ctx.fillStyle = '#2C3E50';
            ctx.fill();
            
            // å˜´å·´å†…éƒ¨ï¼ˆæ·±è‰²ï¼‰
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(s * 0.25, -s * 0.1);
            ctx.lineTo(s * 0.25, s * 0.1);
            ctx.closePath();
            ctx.fillStyle = '#1A252F';
            ctx.fill();
            
            // é”‹åˆ©çš„ç‰™é½¿
            ctx.fillStyle = '#ECF0F1';
            for(let i = 0; i < 4; i++) {
                const y = -s * 0.08 + (i * s * 0.05);
                ctx.beginPath();
                ctx.moveTo(s * 0.15, y);
                ctx.lineTo(s * 0.22, y - s * 0.03);
                ctx.lineTo(s * 0.2, y);
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
            
            // å¤§èƒŒé³ - ä¸‰è§’å½¢ï¼Œå‡¶çŒ›
            ctx.save();
            ctx.translate(s * 0.1, -s * 0.35);
            ctx.rotate(this.finWag * 0.5);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(s * 0.2, -s * 0.9);
            ctx.lineTo(s * 0.4, -s * 0.5);
            ctx.lineTo(s * 0.25, -s * 0.2);
            ctx.closePath();
            const finGrad = ctx.createLinearGradient(0, 0, s * 0.2, -s * 0.9);
            finGrad.addColorStop(0, '#34495E');
            finGrad.addColorStop(1, '#2C3E50');
            ctx.fillStyle = finGrad;
            ctx.fill();
            ctx.strokeStyle = '#1A252F';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
            
            // èƒ¸é³ï¼ˆä¾§é³ï¼‰
            ctx.save();
            ctx.translate(s * 0.2, -s * 0.1);
            ctx.rotate(this.finWag * 0.8);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(s * 0.4, -s * 0.3, s * 0.5, -s * 0.1);
            ctx.quadraticCurveTo(s * 0.3, 0, 0, 0);
            ctx.closePath();
            ctx.fillStyle = '#34495E';
            ctx.fill();
            ctx.restore();
            
            // è…¹é³
            ctx.save();
            ctx.translate(s * 0.25, s * 0.15);
            ctx.rotate(this.finWag * 0.8);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(s * 0.3, s * 0.25, s * 0.4, s * 0.1);
            ctx.quadraticCurveTo(s * 0.25, 0, 0, 0);
            ctx.closePath();
            ctx.fillStyle = '#34495E';
            ctx.fill();
            ctx.restore();
            
            // é³ƒè£‚ï¼ˆ3æ¡ï¼‰
            ctx.strokeStyle = '#1A252F';
            ctx.lineWidth = 1.5;
            for(let i = 0; i < 3; i++) {
                ctx.beginPath();
                const x = -s * 0.1 + (i * s * 0.12);
                ctx.moveTo(x, -s * 0.15);
                ctx.quadraticCurveTo(x + s * 0.05, 0, x, s * 0.15);
                ctx.stroke();
            }
            
            // å‡¶çŒ›çš„çœ¼ç›
            ctx.save();
            ctx.translate(s * 0.45, -s * 0.18);
            // çœ¼ç™½
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 0.2, s * 0.15, 0, 0, Math.PI * 2);
            ctx.fillStyle = '#ECF0F1';
            ctx.fill();
            // ç³å­”ï¼ˆé»‘è‰²ï¼Œå‡¶ç‹ ï¼‰
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.12, 0, Math.PI * 2);
            ctx.fillStyle = '#000';
            ctx.fill();
            // é«˜å…‰
            ctx.beginPath();
            ctx.arc(-s * 0.03, -s * 0.03, s * 0.04, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            // çœ¼ç‘
            ctx.strokeStyle = '#2C3E50';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.2, -0.3, 0.3);
            ctx.stroke();
            ctx.restore();
            
            // ç¬¬äºŒåªçœ¼ç›ï¼ˆåœ¨å¦ä¸€ä¾§ï¼Œç¨å¾®å¯è§ï¼‰
            ctx.save();
            ctx.translate(s * 0.4, s * 0.15);
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 0.15, s * 0.12, 0, 0, Math.PI * 2);
            ctx.fillStyle = '#ECF0F1';
            ctx.fill();
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.09, 0, Math.PI * 2);
            ctx.fillStyle = '#000';
            ctx.fill();
            ctx.restore();
        }
        
        // é‡‘é±¼ - é‡‘è‰²ï¼Œåœ†æ¶¦
        drawGoldfish(ctx, s, bodyWave) {
            // å¤§å°¾å·´
            ctx.save();
            ctx.translate(-s * 0.6, 0);
            ctx.rotate(this.tailWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-s * 0.9, -s * 0.5, -s * 1.3, -s * 0.6);
            ctx.quadraticCurveTo(-s * 1.5, 0, -s * 1.3, s * 0.6);
            ctx.quadraticCurveTo(-s * 0.9, s * 0.5, 0, 0);
            ctx.closePath();
            const tailGrad = ctx.createLinearGradient(-s * 1.3, 0, 0, 0);
            tailGrad.addColorStop(0, '#FFA500');
            tailGrad.addColorStop(1, '#FFD700');
            ctx.fillStyle = tailGrad;
            ctx.fill();
            ctx.restore();
            
            // èº«ä½“ - åœ†æ¶¦
            ctx.save();
            ctx.rotate(bodyWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 1.0, s * 0.75, 0, 0, Math.PI * 2);
            const bodyGrad = ctx.createRadialGradient(-s * 0.2, -s * 0.15, 0, 0, 0, s * 1.0);
            bodyGrad.addColorStop(0, '#FFE135');
            bodyGrad.addColorStop(0.5, '#FFD700');
            bodyGrad.addColorStop(1, '#FFA500');
            ctx.fillStyle = bodyGrad;
            ctx.fill();
            
            // é³ç‰‡çº¹ç†
            ctx.strokeStyle = 'rgba(255, 200, 0, 0.3)';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.arc(0, (i - 1) * s * 0.3, s * 0.4, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
            
            // é±¼é³
            this.drawFins(ctx, s, '#FFD700');
            
            // çœ¼ç›
            this.drawEye(ctx, s * 0.4, -s * 0.1);
        }
        
        // å‰‘é±¼ - é“¶è‰²ï¼Œé•¿å˜´
        drawSwordfish(ctx, s, bodyWave) {
            // é•¿å˜´ï¼ˆå‰‘ï¼‰
            ctx.save();
            ctx.translate(s * 0.8, 0);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(s * 1.2, 0);
            ctx.lineTo(s * 1.0, -s * 0.1);
            ctx.lineTo(s * 0.9, 0);
            ctx.lineTo(s * 1.0, s * 0.1);
            ctx.closePath();
            const swordGrad = ctx.createLinearGradient(0, 0, s * 1.2, 0);
            swordGrad.addColorStop(0, '#E0E0E0');
            swordGrad.addColorStop(1, '#FFFFFF');
            ctx.fillStyle = swordGrad;
            ctx.fill();
            ctx.strokeStyle = '#C0C0C0';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();
            
            // èº«ä½“ - æµçº¿å‹
            ctx.save();
            ctx.rotate(bodyWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 1.3, s * 0.5, 0, 0, Math.PI * 2);
            const bodyGrad = ctx.createRadialGradient(-s * 0.3, 0, 0, 0, 0, s * 1.3);
            bodyGrad.addColorStop(0, '#F0F0F0');
            bodyGrad.addColorStop(0.5, '#C0C0C0');
            bodyGrad.addColorStop(1, '#808080');
            ctx.fillStyle = bodyGrad;
            ctx.fill();
            
            // é“¶è‰²æ¡çº¹
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-s * 0.5, -s * 0.2);
            ctx.lineTo(s * 0.5, s * 0.2);
            ctx.stroke();
            
            ctx.strokeStyle = '#808080';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
            
            // èƒŒé³ - é«˜è€Œå°–
            ctx.save();
            ctx.translate(s * 0.2, -s * 0.3);
            ctx.rotate(this.finWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(s * 0.2, -s * 0.8);
            ctx.lineTo(s * 0.4, -s * 0.5);
            ctx.lineTo(s * 0.2, -s * 0.2);
            ctx.closePath();
            ctx.fillStyle = '#A0A0A0';
            ctx.fill();
            ctx.restore();
            
            // å°¾å·´
            ctx.save();
            ctx.translate(-s * 0.7, 0);
            ctx.rotate(this.tailWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-s * 1.0, -s * 0.6);
            ctx.lineTo(-s * 1.2, 0);
            ctx.lineTo(-s * 1.0, s * 0.6);
            ctx.closePath();
            ctx.fillStyle = '#808080';
            ctx.fill();
            ctx.restore();
            
            // çœ¼ç›
            this.drawEye(ctx, s * 0.5, -s * 0.1);
        }
        
        // è´è¶é±¼ - å¤šå½©ï¼Œä¼˜é›…
        drawButterflyFish(ctx, s, bodyWave) {
            // å°¾å·´
            ctx.save();
            ctx.translate(-s * 0.65, 0);
            ctx.rotate(this.tailWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-s * 0.8, -s * 0.4, -s * 1.1, -s * 0.5);
            ctx.quadraticCurveTo(-s * 1.3, 0, -s * 1.1, s * 0.5);
            ctx.quadraticCurveTo(-s * 0.8, s * 0.4, 0, 0);
            ctx.closePath();
            const tailGrad = ctx.createLinearGradient(-s * 1.1, 0, 0, 0);
            tailGrad.addColorStop(0, '#FF69B4');
            tailGrad.addColorStop(1, '#FFB6C1');
            ctx.fillStyle = tailGrad;
            ctx.fill();
            ctx.restore();
            
            // èº«ä½“ - å¤šå½©æ¸å˜
            ctx.save();
            ctx.rotate(bodyWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 1.1, s * 0.7, 0, 0, Math.PI * 2);
            const bodyGrad = ctx.createRadialGradient(-s * 0.3, -s * 0.2, 0, 0, 0, s * 1.1);
            bodyGrad.addColorStop(0, '#FFB6C1');
            bodyGrad.addColorStop(0.3, '#FF69B4');
            bodyGrad.addColorStop(0.6, '#DA70D6');
            bodyGrad.addColorStop(1, '#9370DB');
            ctx.fillStyle = bodyGrad;
            ctx.fill();
            
            // å½©è‰²æ–‘ç‚¹
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.arc(-s * 0.2, -s * 0.1, s * 0.12, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#00CED1';
            ctx.beginPath();
            ctx.arc(s * 0.2, s * 0.1, s * 0.1, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#9370DB';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
            
            // å¤§èƒŒé³ - åƒè´è¶ç¿…è†€
            ctx.save();
            ctx.translate(s * 0.3, -s * 0.35);
            ctx.rotate(this.finWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(s * 0.3, -s * 0.6, s * 0.6, -s * 0.4);
            ctx.quadraticCurveTo(s * 0.3, -s * 0.2, 0, 0);
            ctx.closePath();
            const finGrad = ctx.createLinearGradient(0, 0, s * 0.6, -s * 0.4);
            finGrad.addColorStop(0, '#FFB6C1');
            finGrad.addColorStop(1, '#FF69B4');
            ctx.fillStyle = finGrad;
            ctx.fill();
            ctx.restore();
            
            // é±¼é³
            this.drawFins(ctx, s, '#FF69B4');
            
            // çœ¼ç›
            this.drawEye(ctx, s * 0.4, -s * 0.12);
        }
        
        // æµ·è±š - ç°è‰²ï¼Œå¿«é€Ÿ
        drawDolphin(ctx, s, bodyWave) {
            // èº«ä½“ - æµçº¿å‹
            ctx.save();
            ctx.rotate(bodyWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 1.4, s * 0.6, 0, 0, Math.PI * 2);
            const bodyGrad = ctx.createRadialGradient(-s * 0.4, -s * 0.2, 0, 0, 0, s * 1.4);
            bodyGrad.addColorStop(0, '#B0C4DE');
            bodyGrad.addColorStop(0.4, '#708090');
            bodyGrad.addColorStop(1, '#2F4F4F');
            ctx.fillStyle = bodyGrad;
            ctx.fill();
            
            // è…¹éƒ¨é«˜å…‰
            ctx.fillStyle = 'rgba(176, 196, 222, 0.6)';
            ctx.beginPath();
            ctx.ellipse(s * 0.2, s * 0.2, s * 0.8, s * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#2F4F4F';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
            
            // èƒŒé³ - ä¸‰è§’å½¢
            ctx.save();
            ctx.translate(s * 0.3, -s * 0.35);
            ctx.rotate(this.finWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(s * 0.3, -s * 0.7);
            ctx.lineTo(s * 0.6, 0);
            ctx.closePath();
            ctx.fillStyle = '#2F4F4F';
            ctx.fill();
            ctx.restore();
            
            // å°¾é³ - æ°´å¹³
            ctx.save();
            ctx.translate(-s * 0.7, 0);
            ctx.rotate(this.tailWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-s * 1.0, -s * 0.5);
            ctx.quadraticCurveTo(-s * 1.2, 0, -s * 1.0, s * 0.5);
            ctx.lineTo(0, 0);
            ctx.closePath();
            ctx.fillStyle = '#708090';
            ctx.fill();
            ctx.restore();
            
            // èƒ¸é³
            ctx.save();
            ctx.translate(s * 0.4, 0);
            ctx.rotate(this.finWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(s * 0.2, s * 0.3, s * 0.3, s * 0.2);
            ctx.quadraticCurveTo(s * 0.2, s * 0.1, 0, 0);
            ctx.closePath();
            ctx.fillStyle = '#708090';
            ctx.fill();
            ctx.restore();
            
            // çœ¼ç›
            this.drawEye(ctx, s * 0.6, -s * 0.15);
        }
        
        // æ°´æ¯ - é€æ˜ï¼Œå‘å…‰
        drawJellyfish(ctx, s, bodyWave) {
            ctx.save();
            // ä¼ç›– - åŠé€æ˜
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.arc(0, -s * 0.3, s * 0.9, Math.PI, 0, false);
            ctx.closePath();
            const capGrad = ctx.createRadialGradient(0, -s * 0.3, 0, 0, -s * 0.3, s * 0.9);
            capGrad.addColorStop(0, 'rgba(230, 230, 250, 0.9)');
            capGrad.addColorStop(0.5, 'rgba(221, 160, 221, 0.6)');
            capGrad.addColorStop(1, 'rgba(186, 85, 211, 0.4)');
            ctx.fillStyle = capGrad;
            ctx.fill();
            
            // ä¼ç›–è¾¹ç¼˜
            ctx.strokeStyle = 'rgba(186, 85, 211, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, -s * 0.3, s * 0.9, Math.PI, 0, false);
            ctx.stroke();
            
            // è§¦é¡» - é£˜åŠ¨
            ctx.strokeStyle = 'rgba(221, 160, 221, 0.7)';
            ctx.lineWidth = s * 0.08;
            for (let i = 0; i < 6; i++) {
                const x = (i - 2.5) * s * 0.3;
                ctx.beginPath();
                ctx.moveTo(x, -s * 0.3);
                const wave = Math.sin(this.frame * 0.1 + i) * s * 0.2;
                ctx.quadraticCurveTo(x + wave, s * 0.2, x, s * 0.8);
                ctx.stroke();
            }
            
            // å‘å…‰ç‚¹
            ctx.globalAlpha = 0.5 + Math.sin(this.frame * 0.2) * 0.3;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-s * 0.2, -s * 0.4, s * 0.1, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(s * 0.2, -s * 0.3, s * 0.08, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // é»˜è®¤é±¼
        drawDefaultFish(ctx, s, bodyWave) {
            // å°¾å·´
            ctx.save();
            ctx.translate(-s * 0.7, 0);
            ctx.rotate(this.tailWag);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-s * 0.8, -s * 0.5, -s * 1.2, -s * 0.6);
            ctx.quadraticCurveTo(-s * 1.4, 0, -s * 1.2, s * 0.6);
            ctx.quadraticCurveTo(-s * 0.8, s * 0.5, 0, 0);
            ctx.closePath();
            const tailGrad = ctx.createLinearGradient(-s * 1.2, 0, 0, 0);
            tailGrad.addColorStop(0, this.type.color + 'CC');
            tailGrad.addColorStop(1, this.type.color);
            ctx.fillStyle = tailGrad;
            ctx.fill();
            ctx.restore();
            
            // èº«ä½“
            ctx.save();
            ctx.rotate(bodyWave);
            ctx.beginPath();
            ctx.ellipse(0, 0, s * 1.1, s * 0.65, 0, 0, Math.PI * 2);
            const bodyGrad = ctx.createRadialGradient(-s * 0.3, -s * 0.2, 0, 0, 0, s * 1.2);
            const lightColor = this.lightenColor(this.type.color, 30);
            const darkColor = this.darkenColor(this.type.color, 20);
            bodyGrad.addColorStop(0, lightColor);
            bodyGrad.addColorStop(0.4, this.type.color);
            bodyGrad.addColorStop(1, darkColor);
            ctx.fillStyle = bodyGrad;
            ctx.fill();
            ctx.strokeStyle = darkColor;
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.restore();
            
            // é±¼é³
            this.drawFins(ctx, s, this.type.color);
            
            // çœ¼ç›
            this.drawEye(ctx, s * 0.4, -s * 0.15);
        }
        
        // ç»˜åˆ¶é±¼é³
        drawFins(ctx, s, color) {
            ctx.save();
            ctx.translate(s * 0.3, 0);
            ctx.rotate(this.finWag);
            
            // ä¸Šé³
            ctx.beginPath();
            ctx.moveTo(0, -s * 0.3);
            ctx.quadraticCurveTo(s * 0.2, -s * 0.5, s * 0.4, -s * 0.4);
            ctx.quadraticCurveTo(s * 0.2, -s * 0.2, 0, -s * 0.3);
            ctx.fillStyle = color + 'AA';
            ctx.fill();
            
            // ä¸‹é³
            ctx.beginPath();
            ctx.moveTo(0, s * 0.3);
            ctx.quadraticCurveTo(s * 0.2, s * 0.5, s * 0.4, s * 0.4);
            ctx.quadraticCurveTo(s * 0.2, s * 0.2, 0, s * 0.3);
            ctx.fill();
            ctx.restore();
        }
        
        // ç»˜åˆ¶çœ¼ç›
        drawEye(ctx, x, y) {
            ctx.save();
            ctx.translate(x, y);
            
            // çœ¼ç™½
            ctx.beginPath();
            ctx.arc(0, 0, this.type.size * 0.2, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            
            // çœ¼çƒ
            ctx.beginPath();
            ctx.arc(this.type.size * 0.05, -this.type.size * 0.02, this.type.size * 0.12, 0, Math.PI * 2);
            ctx.fillStyle = '#000';
            ctx.fill();
            
            // çœ¼ç›é«˜å…‰
            ctx.beginPath();
            ctx.arc(this.type.size * 0.08, -this.type.size * 0.05, this.type.size * 0.04, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.restore();
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šé¢œè‰²å˜äº®
        lightenColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const r = Math.min(255, Math.floor((num >> 16) + percent));
            const g = Math.min(255, Math.floor(((num >> 8) & 0x00FF) + percent));
            const b = Math.min(255, Math.floor((num & 0x0000FF) + percent));
            const hex = ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
            return "#" + hex;
        }
        
        // è¾…åŠ©å‡½æ•°ï¼šé¢œè‰²å˜æš—
        darkenColor(color, percent) {
            const num = parseInt(color.replace("#", ""), 16);
            const r = Math.max(0, Math.floor((num >> 16) - percent));
            const g = Math.max(0, Math.floor(((num >> 8) & 0x00FF) - percent));
            const b = Math.max(0, Math.floor((num & 0x0000FF) - percent));
            const hex = ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
            return "#" + hex;
        }
    }

    class FloatText {
        constructor() { this.active = false; }
        reset(x, y, val) { this.x = x; this.y = y; this.text = "+"+val; this.life = 50; this.active = true; }
        update() { if(!this.active)return; this.y-=1.5; this.life--; if(this.life<=0)this.active=false; }
        draw(ctx) { 
            if(!this.active)return; 
            ctx.save();
            ctx.globalAlpha = Math.min(1, this.life/30); 
            ctx.font = "bold 26px Arial"; 
            ctx.fillStyle="#FFD700"; 
            ctx.strokeStyle="#000"; 
            ctx.lineWidth=3; 
            ctx.strokeText(this.text, this.x, this.y); 
            ctx.fillText(this.text, this.x, this.y); 
            ctx.restore();
        }
    }

    class Particle {
        constructor() { this.active = false; }
        reset(x, y, type, level = 1) {
            this.x=x; this.y=y; this.type=type; this.active=true; this.level = level;
            if(type==='coin') { 
                this.vx=(Math.random()-0.5)*10; 
                this.vy=-Math.random()*10; 
                this.life=60; 
            } else if(type==='explosion') {
                // çˆ†ç‚¸ç²’å­ï¼šå‘å„ä¸ªæ–¹å‘é£æ•£
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 8 + 4;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 20 + Math.random() * 10;
                this.size = Math.random() * 4 + 2;
                // æ ¹æ®ç­‰çº§è®¾ç½®é¢œè‰²
                if(level >= 5) {
                    this.color = ['#FFD700', '#FFA500', '#FF6B00'][Math.floor(Math.random() * 3)];
                } else if(level >= 3) {
                    this.color = ['#FF00FF', '#FF88FF', '#AA00FF'][Math.floor(Math.random() * 3)];
                } else {
                    this.color = ['#00FFFF', '#00AAFF', '#0088FF'][Math.floor(Math.random() * 3)];
                }
            } else if(this.type==='bubble') {
                // æ°”æ³¡ï¼šä»åº•éƒ¨ä¸Šå‡
                this.vx = (Math.random() - 0.5) * 0.5; // æ°´å¹³æ¼‚ç§»
                this.vy = -(Math.random() * 1.5 + 0.8);
                this.life = 200;
                this.r = Math.random() * 6 + 3;
                this.opacity = Math.random() * 0.4 + 0.2;
            } else { 
                this.vx=0; 
                this.vy=-(Math.random()*2+1); 
                this.life=200; 
            }
        }
        update() {
            if(!this.active)return;
            if(this.type==='coin') {
                this.vy+=0.5; this.x+=this.vx; this.y+=this.vy; this.life--;
                if(this.life<30) { const tx=60, ty=40; this.x += (tx-this.x)*0.2; this.y += (ty-this.y)*0.2; if(Math.hypot(this.x-tx, this.y-ty)<10) this.active=false; }
            } else if(this.type==='explosion') {
                // çˆ†ç‚¸ç²’å­å‡é€Ÿå¹¶æ·¡å‡º
                this.vx *= 0.95;
                this.vy *= 0.95;
                this.x += this.vx;
                this.y += this.vy;
                this.life--;
                if(this.life <= 0) this.active = false;
            } else if(this.type==='bubble') {
                // æ°”æ³¡ä¸Šå‡ï¼Œé€æ¸å˜å¤§å˜é€æ˜
                this.x += this.vx;
                this.y += this.vy;
                this.r += 0.01; // ä¸Šå‡æ—¶ç¨å¾®å˜å¤§
                this.opacity = Math.max(0.1, this.opacity - 0.002);
                this.life--;
                if(this.y < -30 || this.opacity <= 0.1 || this.life <= 0) this.active = false;
            } else { 
                this.y+=this.vy; 
                this.x+=Math.sin(this.y*0.05); 
                if(this.y<-10) this.active=false; 
            }
        }
        draw(ctx) {
            if(!this.active)return; 
            ctx.save(); 
            ctx.translate(this.x, this.y);
            if(this.type==='coin') { 
                ctx.scale(Math.abs(Math.sin(this.life*0.2)), 1); 
                ctx.beginPath(); 
                ctx.arc(0,0,10,0,Math.PI*2); 
                ctx.fillStyle='#FFD700'; 
                ctx.fill(); 
                ctx.strokeStyle='#DAA520'; 
                ctx.stroke(); 
            } else if(this.type==='explosion') {
                // ç»˜åˆ¶çˆ†ç‚¸ç²’å­
                ctx.save();
                const alpha = this.life / 30;
                ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, 0, Math.PI * 2);
                ctx.fill();
                // å¤–å±‚å…‰æ™•
                ctx.fillStyle = this.color + '80';
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 1.5, 0, Math.PI * 2);
                ctx.fill();
            ctx.restore();
            } else if(this.type==='bubble') {
                // ç»˜åˆ¶ç¾è§‚çš„æ°”æ³¡
                ctx.save();
                ctx.globalAlpha = this.opacity;
                
                // æ°”æ³¡å¤–åœˆï¼ˆæ›´é€æ˜ï¼‰
                ctx.beginPath();
                ctx.arc(0, 0, this.r, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.fill();
                
                // æ°”æ³¡å†…åœˆï¼ˆé«˜å…‰ï¼‰
                ctx.beginPath();
                ctx.arc(-this.r * 0.3, -this.r * 0.3, this.r * 0.5, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fill();
                
                // æ°”æ³¡è¾¹æ¡†
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(0, 0, this.r, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.restore();
            } else { 
                // é»˜è®¤ç²’å­ - å›ºå®šå¤§å°é¿å…é—ªçƒ
                ctx.fillStyle='rgba(255,255,255,0.2)'; 
                ctx.beginPath(); 
                ctx.arc(0,0,2,0,Math.PI*2); 
                ctx.fill(); 
            }
            ctx.restore();
        }
    }

    function shoot() {
        cannon.recoil = 15;
        // ç›´æ¥æ ¹æ®ç‚¹å‡»ä½ç½®è®¡ç®—å°„å‡»è§’åº¦ï¼ˆä¸ä½¿ç”¨cannon.angleï¼Œå› ä¸ºå®ƒå·²ç»åç§»äº†ï¼‰
        const dx = input.x - cannon.x;
        const dy = input.y - cannon.y;
        const shootAngle = Math.atan2(dy, dx); // ç›´æ¥è®¡ç®—æœå‘ç‚¹å‡»ä½ç½®çš„è§’åº¦
        
        // ä»ç²‰è‰²é±¼çš„å˜´å·´ä½ç½®å‘å°„ï¼ˆè°ƒæ•´åç§»ï¼‰
        const sc = 0.85 + (currentCannonLvl - 1) * 0.05;
        const muzzleOffset = 30 * sc + currentCannonLvl * 2; // ä»é±¼å˜´ä½ç½®
        const mx = cannon.x + Math.cos(shootAngle) * muzzleOffset;
        const my = cannon.y + Math.sin(shootAngle) * muzzleOffset;
        const b = pool.get(pool.bullets, Bullet);
        // ä¼ é€’å°„å‡»è§’åº¦ï¼ˆéœ€è¦å‡å»Math.PI/2ï¼Œå› ä¸ºå­å¼¹çš„resetå‡½æ•°ä¼šåŠ ä¸ŠMath.PI/2ï¼‰
        b.reset(mx, my, shootAngle - Math.PI / 2, currentCannonLvl);
        entities.bullets.push(b);
    }

    function checkAreaCatch(web) {
        entities.fishes.forEach(f => {
            if(!f.active) return;
            const dist = Math.hypot(f.x - web.x, f.y - web.y);
            if(dist < web.r + f.type.size) {
                const baseChance = (web.level * 1.5) / f.health;
                if (Math.random() < Math.min(0.95, baseChance * 0.2)) catchFish(f);
                // ç§»é™¤åŠ é€Ÿé€»è¾‘ï¼Œé±¼è¢«å‡»ä¸­åä¸åŠ é€Ÿ
            }
        });
    }

    function catchFish(fish) {
        fish.active = false;
        const reward = fish.type.score * 5 * currentCannonLvl;
        score += reward; 
        totalKills++; // å¢åŠ å‡»æ€æ•°
        updateScoreUI();
        const ft = pool.get(pool.texts, FloatText); ft.reset(fish.x, fish.y, reward); entities.floatTexts.push(ft);
        const coinCount = Math.min(10, Math.ceil(reward / 10));
        for(let i=0; i<coinCount; i++) { const p = pool.get(pool.particles, Particle); p.reset(fish.x, fish.y, 'coin'); entities.particles.push(p); }
        
        // Bosså‡»æ€ç‰¹æ®Šæç¤º
        if (fish.type.id === 4) {
            showToast("ğŸ‰ æˆåŠŸæ•è·æ·±æµ·å·¨é²¨ï¼", 2000);
        }
    }

    function loop() {
        if(!isPlaying) return;
        if(isPaused) {
            requestAnimationFrame(loop);
            return; // æš‚åœæ—¶åªç»§ç»­å¾ªç¯ï¼Œä¸æ›´æ–°æ¸¸æˆ
        }
        requestAnimationFrame(loop);
        frameCount++;
        
        // å®Œå…¨é‡ç½®canvasçŠ¶æ€ï¼Œç¡®ä¿æ¯å¸§ä»å¹²å‡€çŠ¶æ€å¼€å§‹
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
        
        // æ¸…é™¤ç”»å¸ƒ - ä½¿ç”¨clearRectï¼ˆæ€§èƒ½æ›´å¥½ï¼Œé¿å…é—ªçƒï¼‰
        ctx.clearRect(0, 0, width, height);
        
        // ç»˜åˆ¶èƒŒæ™¯
        ctx.save();
        if (bgImageLoaded && bgImage.complete && bgImage.naturalWidth > 0) {
            // ä½¿ç”¨èƒŒæ™¯å›¾
            const scale = Math.max(width / bgImage.width, height / bgImage.height);
            const scaledWidth = bgImage.width * scale;
            const scaledHeight = bgImage.height * scale;
            const x = (width - scaledWidth) / 2;
            const y = (height - scaledHeight) / 2;
            ctx.drawImage(bgImage, x, y, scaledWidth, scaledHeight);
            
            // ç§»é™¤é®ç½©å±‚ï¼Œè®©ç”»é¢æ›´æ˜äº®
        } else {
            // ä½¿ç”¨æ¸å˜èƒŒæ™¯
            let grd = ctx.createLinearGradient(0, 0, 0, height);
            grd.addColorStop(0, "#001020");
            grd.addColorStop(1, "#003050");
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, width, height);
        }
        ctx.restore();

        // æ£€æŸ¥ç ´äº§ï¼šå¦‚æœé‡‘å¸ä¸è¶³æœ€ä½ç­‰çº§ç‚®å°è´¹ç”¨ï¼Œæ¸¸æˆç»“æŸ
        const minCost = CANNON_COSTS[1]; // æœ€ä½ç­‰çº§ï¼ˆ1çº§ï¼‰çš„è´¹ç”¨
        if(score < minCost) {
            endGame();
            return;
        }

        // é±¼ç”Ÿæˆé€»è¾‘ - æ ¹æ®æŒ‘æˆ˜æœºåˆ¶
        if(entities.fishes.length < 25 && Math.random() < 0.04) {
            const fish = new Fish();
            entities.fishes.push(fish);
        }
        if(Math.random() < 0.05) { const p = pool.get(pool.particles, Particle); p.reset(Math.random()*width, height, 'bubble'); entities.particles.push(p); }

        // å…ˆæ›´æ–°æ‰€æœ‰å®ä½“
        entities.particles.forEach(p => p.update());
        entities.fishes.forEach(f => f.update());
        
        // å†ç»˜åˆ¶æ‰€æœ‰å®ä½“ - ä½¿ç”¨å€’åºéå†é¿å…spliceå¯¼è‡´çš„ç´¢å¼•é—®é¢˜
        ctx.save();
        for(let i = entities.particles.length - 1; i >= 0; i--) {
            const p = entities.particles[i];
            if(p.active) {
                p.draw(ctx);
            } else {
                entities.particles.splice(i, 1);
            }
        }
        ctx.restore();
        
        ctx.save();
        for(let i = entities.fishes.length - 1; i >= 0; i--) {
            const f = entities.fishes[i];
            if(f.active) {
                f.draw(ctx);
            } else {
                entities.fishes.splice(i, 1);
            }
        }
        ctx.restore();

        // æ›´æ–°å’Œç»˜åˆ¶å­å¼¹
        ctx.save();
        for(let i=entities.bullets.length-1; i>=0; i--) {
            let b = entities.bullets[i]; 
            b.update(); 
            if(b.active) b.draw(ctx);
            let hitFish = null;
            let hitPoint = null; // è®°å½•å‡»ä¸­ç‚¹
            for(let f of entities.fishes) { 
                if(f.active && Math.abs(f.x - b.x) < f.type.size + 10 && Math.abs(f.y - b.y) < f.type.size + 10) { 
                    hitFish = f;
                    hitPoint = {x: b.x, y: b.y}; // è®°å½•å‡»ä¸­ä½ç½®
                    break; 
                } 
            }
            if(hitFish || !b.active) {
                if(hitFish) { 
                    // åˆ›å»ºçˆ†ç‚¸ç²’å­æ•ˆæœ
                    const particleCount = 12 + b.level * 3;
                    for(let j = 0; j < particleCount; j++) {
                        const p = pool.get(pool.particles, Particle);
                        p.reset(b.x, b.y, 'explosion', b.level);
                        entities.particles.push(p);
                    }
                    
                    // è®¡ç®—å‡»ä¸­éƒ¨ä½ï¼ˆå¤´éƒ¨ã€èº«ä½“ã€å°¾å·´ï¼‰
                    const s = hitFish.type.size;
                    // å°†å‡»ä¸­ç‚¹è½¬æ¢åˆ°é±¼çš„å±€éƒ¨åæ ‡ç³»
                    const dx = hitPoint.x - hitFish.x;
                    const dy = hitPoint.y - hitFish.y;
                    // æ ¹æ®é±¼çš„æœå‘æ—‹è½¬å›å±€éƒ¨åæ ‡
                    const cos = Math.cos(-hitFish.angle);
                    const sin = Math.sin(-hitFish.angle);
                    const localX = dx * cos - dy * sin;
                    const localY = dx * sin + dy * cos;
                    
                    // åˆ¤æ–­å‡»ä¸­éƒ¨ä½ï¼šå¤´éƒ¨åœ¨å‰æ–¹ï¼ˆlocalX > 0ï¼‰ï¼Œå°¾å·´åœ¨åæ–¹ï¼ˆlocalX < -s*0.5ï¼‰
                    let damageMultiplier = 1.0; // é»˜è®¤èº«ä½“ä¼¤å®³
                    let hitPart = 'body';
                    if (localX > s * 0.3) {
                        // å¤´éƒ¨åŒºåŸŸ
                        damageMultiplier = 2.0;
                        hitPart = 'head';
                    } else if (localX < -s * 0.5) {
                        // å°¾å·´åŒºåŸŸ
                        damageMultiplier = 0.5;
                        hitPart = 'tail';
                    }
                    
                    // æ ¹æ®éƒ¨ä½è®¡ç®—ä¼¤å®³
                    const baseChance = (b.level * 1.5 * damageMultiplier) / hitFish.health;
                    if (Math.random() < Math.min(0.95, baseChance * 0.3)) {
                        catchFish(hitFish);
                    }
                    // ç§»é™¤åŠ é€Ÿé€»è¾‘ï¼Œé±¼è¢«å‡»ä¸­åä¸åŠ é€Ÿ
                }
                b.active = false; entities.bullets.splice(i, 1);
            }
        }
        ctx.restore();
        
        // ç»˜åˆ¶æ¶Ÿæ¼ª - ä½¿ç”¨å€’åºéå†é¿å…ç´¢å¼•é—®é¢˜
        ctx.save();
        for(let i = entities.ripples.length - 1; i >= 0; i--) {
            const r = entities.ripples[i];
            r.update();
            if(r.active) {
                r.draw(ctx);
            } else {
                entities.ripples.splice(i, 1);
            }
        }
        ctx.restore();
        
        // ç»˜åˆ¶ç‚®å°
        ctx.save();
        cannon.update(); 
        cannon.draw(ctx);
        ctx.restore();
        
        // ç»˜åˆ¶æµ®åŠ¨æ–‡å­— - ä½¿ç”¨å€’åºéå†é¿å…ç´¢å¼•é—®é¢˜
        ctx.save();
        for(let i = entities.floatTexts.length - 1; i >= 0; i--) {
            const t = entities.floatTexts[i];
            t.update();
            if(t.active) {
                t.draw(ctx);
            } else {
                entities.floatTexts.splice(i, 1);
            }
        }
        ctx.restore();
        
        // æ›´æ–°Bossè­¦å‘Š
        updateBossWarning();
        
        // ç»˜åˆ¶Bossè­¦å‘Šæ•ˆæœï¼ˆå¦‚æœæœ‰Bossåœ¨åœºï¼‰
        const activeBoss = entities.fishes.find(f => f.active && f.type.id === 4);
        if (activeBoss || bossWarningActive) {
            ctx.save();
            ctx.globalAlpha = 0.15;
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(0, 0, width, height);
            ctx.restore();
        }
    }

    // ========== é¦–é¡µåŠ¨ç”» ==========
    const hpCanvas = document.getElementById('homepageCanvas');
    const hpCtx = hpCanvas.getContext('2d');
    let hpFrame = 0;
    let homepageBubbles = [];
    let homepageFish = [];
    let lightRays = [];
    let hpAnimationId = null;
    
    // æ°”æ³¡ç±»
    class HomepageBubble {
        constructor(w, h) {
            this.w = w;
            this.h = h;
            this.reset();
        }
        reset() {
            this.x = Math.random() * this.w;
            this.y = this.h + Math.random() * 50;
            this.r = Math.random() * 10 + 4;
            this.speed = Math.random() * 1.5 + 0.8;
            this.opacity = Math.random() * 0.5 + 0.3;
            this.drift = (Math.random() - 0.5) * 0.8;
        }
        update() {
            this.y -= this.speed;
            this.x += this.drift + Math.sin(hpFrame * 0.03 + this.x * 0.01) * 0.3;
            this.r += 0.01;
            this.opacity = Math.max(0.1, this.opacity - 0.001);
            if (this.y < -30 || this.opacity <= 0.1) this.reset();
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.opacity;
            // æ°”æ³¡å¤–åœˆ
            ctx.beginPath();
            ctx.fillStyle = 'rgba(72, 202, 228, 0.2)';
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            ctx.fill();
            // æ°”æ³¡é«˜å…‰
            ctx.beginPath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.arc(this.x - this.r * 0.3, this.y - this.r * 0.3, this.r * 0.4, 0, Math.PI * 2);
            ctx.fill();
            // æ°”æ³¡è¾¹æ¡†
            ctx.strokeStyle = 'rgba(72, 202, 228, 0.4)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }
    }
    
    // å…‰æ–‘ç±»
    class LightRay {
        constructor(w, h) {
            this.w = w;
            this.h = h;
            this.reset();
        }
        reset() {
            this.x = Math.random() * this.w;
            this.y = Math.random() * this.h;
            this.size = Math.random() * 120 + 60;
            this.opacity = Math.random() * 0.25 + 0.08;
            this.speed = Math.random() * 0.4 + 0.15;
            this.angle = Math.random() * Math.PI * 2;
        }
        update() {
            this.x += Math.cos(this.angle) * this.speed;
            this.y += Math.sin(this.angle) * this.speed;
            this.opacity += Math.sin(hpFrame * 0.03 + this.x * 0.01) * 0.03;
            this.opacity = Math.max(0.05, Math.min(0.35, this.opacity));
            if (this.x < -this.size || this.x > this.w + this.size ||
                this.y < -this.size || this.y > this.h + this.size) {
                this.reset();
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.opacity;
            const grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size);
            grad.addColorStop(0, 'rgba(72, 202, 228, 0.5)');
            grad.addColorStop(0.5, 'rgba(0, 119, 182, 0.2)');
            grad.addColorStop(1, 'rgba(0, 119, 182, 0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }
    
    // é¦–é¡µé±¼ç±» - ä½¿ç”¨æ¸¸æˆå†…çš„é±¼ç§
    class HomepageFish {
        constructor(w, h) {
            this.w = w;
            this.h = h;
            this.frame = 0;
            this.tailWag = 0;
            this.finWag = 0;
            this.reset();
        }
        reset() {
            this.direction = Math.random() > 0.5 ? 1 : -1;
            this.x = this.direction > 0 ? -60 : this.w + 60;
            this.y = Math.random() * this.h * 0.8 + this.h * 0.1;
            // ä»æ¸¸æˆå†…çš„é±¼ç§ä¸­éšæœºé€‰æ‹©ï¼ˆæ’é™¤Bossï¼‰
            const availableTypes = FISH_TYPES.filter(f => f.id !== 4); // æ’é™¤Boss
            this.type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            this.speed = (this.type.speed * 0.5 + Math.random() * 0.3) * this.direction; // é¦–é¡µé±¼æ¸¸å¾—æ…¢ä¸€äº›
            this.opacity = Math.random() * 0.3 + 0.5;
            this.angle = this.direction > 0 ? 0 : Math.PI;
            this.frame = Math.random() * 100;
        }
        update() {
            this.x += this.speed;
            this.frame += 0.1;
            this.tailWag = Math.sin(this.frame * 0.2) * 0.4;
            this.finWag = Math.cos(this.frame * 0.15) * 0.3;
            if ((this.direction > 0 && this.x > this.w + 80) ||
                (this.direction < 0 && this.x < -80)) {
                this.reset();
            }
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.opacity;
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            
            // ä½¿ç”¨æ¸¸æˆå†…Fishç±»çš„ç»˜åˆ¶æ–¹æ³•
            const s = this.type.size * 0.8; // é¦–é¡µé±¼ç¨å¾®å°ä¸€ç‚¹
            const bodyWave = Math.sin(this.frame * 0.12) * 0.05;
            const fishId = this.type.id;
            
            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„Fishå¯¹è±¡æ¥ä½¿ç”¨å…¶ç»˜åˆ¶æ–¹æ³•
            const tempFish = new Fish();
            tempFish.type = this.type;
            tempFish.tailWag = this.tailWag;
            tempFish.finWag = this.finWag;
            tempFish.frame = this.frame;
            tempFish.wobble = 0;
            
            // è°ƒç”¨Fishç±»çš„ç»˜åˆ¶æ–¹æ³•
            tempFish.drawFishByType(ctx, s, bodyWave, fishId);
            
            ctx.restore();
        }
    }
    
    // åˆå§‹åŒ–é¦–é¡µåŠ¨ç”»
    function initHomepageAnimation() {
        hpCanvas.width = window.innerWidth;
        hpCanvas.height = window.innerHeight;
        const w = hpCanvas.width;
        const h = hpCanvas.height;
        
        homepageBubbles = [];
        for (let i = 0; i < 35; i++) {
            homepageBubbles.push(new HomepageBubble(w, h));
        }
        
        lightRays = [];
        for (let i = 0; i < 6; i++) {
            lightRays.push(new LightRay(w, h));
        }
        
        homepageFish = [];
        for (let i = 0; i < 12; i++) {
            homepageFish.push(new HomepageFish(w, h));
        }
        
        startHomepageAnimation();
    }
    
    // é¦–é¡µåŠ¨ç”»å¾ªç¯
    function homepageAnimationLoop() {
        hpFrame++;
        hpCtx.clearRect(0, 0, hpCanvas.width, hpCanvas.height);
        
        // ç»˜åˆ¶èƒŒæ™¯å›¾ï¼ˆå¦‚æœæœ‰ï¼‰
        if (bgImageLoaded && bgImage.complete && bgImage.naturalWidth > 0) {
            const scale = Math.max(hpCanvas.width / bgImage.width, hpCanvas.height / bgImage.height);
            const w = bgImage.width * scale;
            const h = bgImage.height * scale;
            const x = (hpCanvas.width - w) / 2;
            const y = (hpCanvas.height - h) / 2;
            hpCtx.drawImage(bgImage, x, y, w, h);
        }
        
        // ç»˜åˆ¶å…‰æ–‘
        for (let ray of lightRays) {
            ray.update();
            ray.draw(hpCtx);
        }
        
        // ç»˜åˆ¶æ°”æ³¡
        for (let bubble of homepageBubbles) {
            bubble.update();
            bubble.draw(hpCtx);
        }
        
        // ç»˜åˆ¶é±¼
        for (let fish of homepageFish) {
            fish.update();
            fish.draw(hpCtx);
        }
        
        hpAnimationId = requestAnimationFrame(homepageAnimationLoop);
    }
    
    function startHomepageAnimation() {
        if (!hpAnimationId) {
            homepageAnimationLoop();
        }
    }
    
    function stopHomepageAnimation() {
        if (hpAnimationId) {
            cancelAnimationFrame(hpAnimationId);
            hpAnimationId = null;
        }
    }
    
    // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼ˆé¦–é¡µåŠ¨ç”»ï¼‰
    window.addEventListener('resize', () => {
        if (!isPlaying) {
            hpCanvas.width = window.innerWidth;
            hpCanvas.height = window.innerHeight;
            const w = hpCanvas.width;
            const h = hpCanvas.height;
            // é‡ç½®æ‰€æœ‰å…ƒç´ çš„å°ºå¯¸å¼•ç”¨
            homepageBubbles.forEach(b => { b.w = w; b.h = h; });
            lightRays.forEach(r => { r.w = w; r.h = h; });
            homepageFish.forEach(f => { f.w = w; f.h = h; });
        }
    });
    
    // ä¿®æ”¹startGameå’ŒquitGameå‡½æ•°ï¼Œæ§åˆ¶åŠ¨ç”»
    const originalStartGame = window.startGame;
    window.startGame = function() {
        stopHomepageAnimation();
        originalStartGame();
    };
    
    const originalQuitGame = window.quitGame;
    window.quitGame = function() {
        originalQuitGame();
        setTimeout(() => {
            initHomepageAnimation();
        }, 100);
    };
    
    // æ›´æ–°é¦–é¡µé‡‘å¸æ˜¾ç¤º
    function updateHomepageScore() {
        const homepageScoreEl = document.getElementById('homepage-score');
        if (homepageScoreEl) {
            homepageScoreEl.innerText = Math.floor(score);
        }
    }
    
    // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–æ¸¸æˆæ•°æ®å’ŒèƒŒæ™¯å›¾
    window.addEventListener('DOMContentLoaded', function() {
        loadGameData();
        updateScoreUI(); // æ›´æ–°æ¸¸æˆUIæ˜¾ç¤ºä¿å­˜çš„é‡‘å¸
        updateHomepageScore(); // æ›´æ–°é¦–é¡µé‡‘å¸æ˜¾ç¤º
        loadBackgroundImage(); // åŠ è½½èƒŒæ™¯å›¾ï¼Œç¡®ä¿é¦–é¡µä¹Ÿèƒ½æ˜¾ç¤º
    });
    
    // å¯åŠ¨é¦–é¡µåŠ¨ç”»
    initHomepageAnimation();
</script>
</body>
</html>